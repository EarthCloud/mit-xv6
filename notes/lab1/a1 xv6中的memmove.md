```c
void*

memmove(void *vdst, const void *vsrc, int n)

{

  char *dst;

  const char *src;

  

  dst = vdst;

  src = vsrc;

  if (src > dst) {

    while(n-- > 0)

      *dst++ = *src++;

  } else {

    dst += n;

    src += n;

    while(n-- > 0)

      *--dst = *--src;

  }

  return vdst;

}
```

## 功能：安全地将内存从源地址（Source）复制到目标地址（Destination）

常见的memcpy函数通常假设内存不重叠，直接从头到尾复制。但在内存重叠的情况下，盲目地从头复制会导致**源数据在被读取之前就被覆盖掉**。

因此，我们需要使用该函数逐位复制。

同时，我们也能看到，xv6的用户库`ulib.c`中将memcpy重定向到memmove：

```c
void *

memcpy(void *dst, const void *src, uint n)

{

  return memmove(dst, src, n);

}
```

## 1. 逻辑解析

标准的 `memcpy` 函数通常假设内存不重叠，直接从头到尾复制。但在内存重叠的情况下，盲目地从头复制会导致**源数据在被读取之前就被覆盖掉**。

`memmove` 通过判断源地址和目标地址的相对位置，决定是**“从前往后拷”**还是**“从后往前拷”**。

- **情况 A：`src > dst`（源地址在高位，目标在低位）**
    
    - **场景**：要把一段数据向前挪动。
        
    - **策略**：**从前往后复制**（Forward Copy）。
        
    - **代码**：

        ```c
        while(n-- > 0)
          *dst++ = *src++;
        ```
        
    - **原因**：复制头部数据时，覆盖的是 `dst` 的头部，这部分不属于 `src` 的有效数据区域（或者还没轮到 `src` 的头部），所以安全。
        
- **情况 B：`src <= dst`（源地址在低位，目标在高位）**
    
    - **场景**：要把一段数据向后挪动（这最容易出 Bug）。
        
    - **危险**：如果从头开始拷，`dst` 的头部可能会覆盖掉 `src` 的尾部。当你读到 `src` 尾部时，读到的已经是被修改过的数据了。
        
    - **策略**：**从后往前复制**（Backward Copy）。
        
    - **代码**：
        
        
        ```c
        dst += n; // 指针移到末尾
        src += n;
        while(n-- > 0)
          *--dst = *--src; // 倒着拷
        ```
        
    - **原因**：先处理尾部，`dst` 的尾部覆盖的是 `src` 后面未使用的空间（或者还没轮到 `src` 的部分），从而保护了 `src` 前面的数据不被破坏。

## 2. 为什么要使用char？

对于void* 类型的变量，不知道它的默认单位大小，无法执行自增自减操作，而强转为char* 之后，由于char的单个字符占1字节，自增自减操作直接移动一个字节，符合语义。

## 3. 运算符执行顺序

先说结论：

- `++`（后缀自增）：优先级 **高** (Level 1)
- `*` （解引用）：优先级 **中** (Level 2)
- `=` （赋值）：优先级 **低** (Level 14)

**执行步骤分解：**

1. **处理 `src++`**：
    
    - 后缀 `++` 优先级高于 `*`。
        
    - **关键点**：后缀自增的语义是“先取值，后增加”。
        
    - 表达式使用的是 `src` **当前指向的地址**。
        
    - 副作用：`src` 指针向后移动一位（但在本语句执行完之前，表达式用的是旧地址）。
        
2. **处理 `*src`**：
    
    - 对步骤 1 中取到的旧地址进行解引用，取出数据（Byte）。
        
3. **处理 `dst++`**：
    
    - 同理，取 `dst` 当前地址，副作用是 `dst` 指针向后移动一位。
        
4. **处理 `*dst`**：
    
    - 对 `dst` 的旧地址进行解引用。
        
5. **处理 `=`**：
    
    - 把步骤 2 取出的数据，写入步骤 4 指向的内存。
        

**一句话总结**：把当前 `src` 的值赋给 `dst`，然后两个指针各自向后移一步。

