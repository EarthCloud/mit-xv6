## 1. 环境配置

使用WSL2的Ubuntu进行环境搭建，在home/earthcloud下新建一个软连接xv6-labs指向实体机的xv6-labs目录，使用ln命令创建软链接

```shell
ln -s /mnt/d/Code/OS/mit-xv6/xv6-labs-2020 ~/xv6-labs
```

更新包管理器

```shell
sudo apt update && sudo apt upgrade -y
```

安装核心工具链

```shell
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu
```

由于我已经成功挂载，所以只需要进入目录中即可。

### issue 1：QEMU兼容性

现在的环境组合（**xv6 2020源码 + QEMU 8.2.2**）是**完全不兼容**的。QEMU 8.x 引入了严格的 PMP（物理内存保护）和新的中断控制器标准，而 xv6 的老代码没有初始化这些硬件，导致一开机就被硬件“锁死”。这花费了我一下午的时间去调整，但最好的方法还是使用MIT推荐的版本。目前没有找到使用QEMU 8.2.2快速make的方法。

继续修补参数已经没有意义了。为了能顺利做实验，我们必须采用**终极方案**：**手动安装旧版 QEMU (5.1.0)**。这是 MIT 课程官方推荐的版本。



---

#### 第一步：安装编译依赖

我们需要从源码编译一个老版本的 QEMU。首先安装必要的库：


```bash
sudo apt-get update
sudo apt-get install -y git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev ninja-build
```

#### 第二步：下载 QEMU 5.1.0 源码

我们将下载 MIT 官方使用的那个特定版本：


```bash
# 回到 home 目录
cd ~

# 下载源码包
wget https://download.qemu.org/qemu-5.1.0.tar.xz

# 解压
tar xf qemu-5.1.0.tar.xz

# 进入目录
cd qemu-5.1.0
```

#### 第三步：配置并编译

我们只需要编译 RISC-V 64位的模拟器，这样速度很快。


```bash
# 1. 配置 (只编译 riscv64 版本)
./configure --target-list=riscv64-softmmu --prefix=/usr/local

# 2. 编译 (利用 8 个线程加速)
make -j8
```

_(这一步可能需要几分钟，请耐心等待跑完)_


```bash
# 3. 安装到系统
sudo make install
```

#### 第四步：验证版本

安装完成后，我们需要确认系统现在使用的是旧版本：


```bash
qemu-system-riscv64 --version
```

- **期望输出**：`QEMU emulator version 5.1.0`
- **如果还是 8.2.2**：你需要重启一下终端，或者运行 `hash -r` 清除缓存。

---

### issue 2：高版本gcc的严格检查导致无法通过编译


刚开始使用`make qemu`

```text
riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o user/sh.o user/sh.c
user/sh.c: In function ‘runcmd’:
user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion]
   58 | runcmd(struct cmd *cmd)
      | ^~~~~~
user/sh.c:89:5: note: recursive call
   89 |     runcmd(rcmd->cmd);
      |     ^~~~~~~~~~~~~~~~~
user/sh.c:109:7: note: recursive call
  109 |       runcmd(pcmd->left);
      |       ^~~~~~~~~~~~~~~~~~
user/sh.c:116:7: note: recursive call
  116 |       runcmd(pcmd->right);
      |       ^~~~~~~~~~~~~~~~~~~
user/sh.c:95:7: note: recursive call
   95 |       runcmd(lcmd->left);
      |       ^~~~~~~~~~~~~~~~~~
user/sh.c:97:5: note: recursive call
   97 |     runcmd(lcmd->right);
      |     ^~~~~~~~~~~~~~~~~~~
user/sh.c:127:7: note: recursive call
  127 |       runcmd(bcmd->cmd);
      |       ^~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
make: *** [<builtin>: user/sh.o] Error 1
```

这是一个非常常见的编译错误，尤其是在使用较新版本的 GCC（如 GCC 11/12/13）编译 xv6 时。

**错误原因：** 编译器（GCC）极其严格地检查了你的代码，它认为 `runcmd` 函数在**所有**可能的执行路径上都会再次调用 `runcmd`，从而导致无限递归（栈溢出）。

这通常是因为编译器不知道 `exec` 和 `exit` 这两个函数是“不返回”的（No Return）。在 xv6 的简单头文件中，没有给这些系统调用加上 `__attribute__((noreturn))` 标记，所以编译器认为它们只是普通函数，执行完会继续往下走。

**解决方案**：修改 Makefile（推荐，最快解决）

这是最简单的方案，因为这是编译器太“聪明”导致的误报。我们可以禁止将这个特定的警告视为错误。

1. 打开 xv6 根目录下的 `Makefile`。
2. 找到 `CFLAGS` 的定义（通常在文件开头附近）。
3. 在 `CFLAGS` 的末尾添加 `-Wno-infinite-recursion`。

修改后的 `CFLAGS` 看起来应该像这样（注意最后加的那部分）：

```Makefile
CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -Wno-infinite-recursion
```

4. 保存文件。
5. 在终端运行 `make clean` 然后运行 `make qemu`。

