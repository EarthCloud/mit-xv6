文件描述符(File Descriptor)是一个小整数(small integer)，表示进程可以读取或写入的由内核管理的对象。

进程可以通过：

- 打开一个文件、目录、设备
- 创建一个管道
- 复制一个已存在的描述符

来获得一个文件描述符，我们通常将文件描述符所指的对象称为“文件”。

文件描述符接口将文件、管道和设备之间的差异抽象出来，使它们看起来都像字节流。我们将输入和输出称为 I/O。

## 4. 文件描述符

*在内部，xv6内核使用文件描述符作为每个进程表的索引，这样每个进程都有一个从零开始的文件描述符的私有空间。*

这句话非常拗口也比较难理解，下面简要说明一下：

我们需要把这句话拆解成三个部分：数据结构、索引机制、以及所谓的“私有空间”。

### 数据结构

在 xv6 的内核代码 (`kernel/proc.h`) 中，每个进程由一个结构体 `struct proc` 表示。这个结构体里有一个非常关键的数组：

```c
// kernel/proc.h
struct proc {
  // ... 其他属性 ...
  struct file *ofile[NOFILE];  // 打开文件表（Open File Table）
  // ...
};
```

- `NOFILE` 通常是 16。这意味着每个进程最多能同时打开 16 个文件。
- `ofile` 是一个指针数组。它里面存的不是文件的数据，而是指向**内核全局文件表**中某个文件结构体的**指针**。


### 索引机制

当你调用 `fd = open(...)` 时，操作系统返回给你一个整数（比如 3）。 这句话的意思是：**这个整数 `3`，实际上就是 `ofile` 数组的下标（Index）。**

当你在用户空间调用 `write(3, "hi", 2)` 时，内核会做以下操作：

1. 找到当前进程的 `struct proc`。
2. 找到 `proc->ofile` 数组。
3. 取出 `proc->ofile[3]`。
4. 顺着这个指针找到真正的文件对象，然后写入数据。


### 私有空间

这是这句话的精髓。

假设有两个进程：**进程 A** 和 **进程 B**。

- **进程 A** 打开了一个文件 `hello.txt`，系统把它的指针放在了 A 的 `ofile[3]` 位置。于是，对 A 来说，FD **3** 代表 `hello.txt`。
- **进程 B** 打开了一个完全不同的文件 `server.log`，系统把它的指针放在了 B 的 `ofile[3]` 位置。于是，对 B 来说，FD **3** 代表 `server.log`。

**这就是“私有空间”的含义：** 虽然 A 和 B都在使用数字 **3**，但因为它们查找的是**各自独立**的 `ofile` 数组，所以这个 **3** 对应的物理含义完全不同。


各进程打开的文件是相互隔离的。



## 5. 默认文件描述符

按照惯例，进程从文件描述符0读取（标准输入），将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。正如我们将看到的，shell利用这个约定来实现I/O重定向和管道。shell确保它始终有三个打开的文件描述符（**_user/sh.c_**:151），这是控制台的默认文件描述符。由于其他进程都是shell的子进程，所以他们都有固定的这三个fd。

`read`和`write`系统调用以字节为单位读取或写入已打开的以文件描述符命名的文件。`read(fd，buf，n)`从文件描述符fd读取最多n字节，将它们复制到buf，并返回读取的字节数，引用文件的每个文件描述符都有一个与之关联的偏移量。`read`从当前文件偏移量开始读取数据，然后将该偏移量前进所读取的字节数：（也就是说）后续读取将返回第一次读取返回的字节之后的字节。当没有更多的字节可读时，`read`返回0来表示文件的结束。

系统调用`write(fd，buf，n)`将buf中的n字节写入文件描述符，并返回写入的字节数。只有发生错误时才会写入小于n字节的数据。与读一样，`write`在当前文件偏移量处写入数据，然后将该偏移量向前推进写入的字节数：每个`write`从上一个偏移量停止的地方开始写入。

### 6. IO重定向

使用fork创建的子进程会继承父进程的ofile数组，因此这是shell实现io重定向的关键：

当父进程（Shell）调用 `fork()` 生成子进程时，内核会把父进程的 `ofile` 数组（也就是上一节说的那个“私有表”）**按位拷贝（Byte-for-byte copy）** 给子进程。

这意味着：

- **私有表是新的**：子进程有自己的 `ofile` 数组，修改数组里的内容不会影响父进程（比如子进程关闭了 fd 1，父进程的 fd 1 还在）。
- **指针是旧的**：子进程数组里的**指针值**和父进程一模一样。

**结果就是：** 父子进程的 FD 1 都指向了内存中**同一个** `struct file` 对象（这个对象代表控制台 Console）。

正是因为这种继承机制，我们在写 `ls` 或 `Hello World` 程序时，根本不需要写代码去“打开”显示器，因为早在程序运行之前，Shell 已经帮我们把路铺好了。

流程如下：

1. **xv6 启动**：内核启动第一个进程 `init`。
2. **Init 的工作**：`init` 进程会显式地打开控制台设备（Console），这会占据它的 0, 1, 2 号描述符。
3. **Init 派生 Shell**：`init` 调用 `fork()` 启动 `sh`。**`sh` 继承了 0, 1, 2**。
4. **Shell 派生命令**：当你输入 `ls` 时，`sh` 调用 `fork()`。**子进程继承了 0, 1, 2**。
5. **Exec 替换**：子进程调用 `exec("ls", ...)`。**关键点来了：`exec` 会替换代码和内存，但通常会保留文件描述符表！**
6. **程序运行**：`ls` 开始运行，它的 `printf` 默认往 fd 1 写数据。由于 fd 1 指向控制台，字符就出现在了屏幕上。

这也就是为何，shell不把fork和exec写在一起构成新函数，文件描述符和`fork`相互作用，使I/O重定向更容易实现。`fork`复制父进程的文件描述符表及其内存，以便子级以与父级在开始时拥有完全相同的打开文件。系统调用`exec`替换了调用进程的内存，但保留其文件表。此行为允许shell通过`fork`实现I/O重定向，在子进程中重新打开选定的文件描述符，然后调用`exec`来运行新程序。

Xv6shell中的I/O重定向代码就是这样工作的(**_user/sh.c_**:82)。回想一下，在代码执行到这里时，shell已经`fork`出了子shell，`runcmd`将调用`exec`来加载新程序，下面是REDIR的实现：

```c
  case REDIR:

    rcmd = (struct redircmd*)cmd;

    close(rcmd->fd);

    if(open(rcmd->file, rcmd->mode) < 0){

      fprintf(2, "open %s failed\n", rcmd->file);

      exit(1);

    }

    runcmd(rcmd->cmd);

    break;
```

可以看到，关闭了原先的fd，再重新打开一个fd，这样就成功实现了重定向。

尽管`fork`复制了文件描述符表，但是每个基础文件偏移量在父文件和子文件之间是共享的，比如下面的程序：

```c
if (fork() == 0) {
    write(1, "hello ", 6);
    exit(0);
} else {
    wait(0);
    write(1, "world\n", 6);
}

```

在这个片段的末尾，附加到文件描述符1的文件将包含数据`hello world`。父进程中的写操作(由于等待，只有在子进程完成后才运行)在子进程停止写入的位置进行。这种行为有助于从shell命令序列产生顺序输出，比如`(echo hello;echo world) >output.txt`。

## 7. dup系统调用

`dup`系统调用复制一个现有的文件描述符，返回一个引用自同一个底层I/O对象的新文件描述符。两个文件描述符共享一个偏移量。