Xv6文件系统提供数据文件（包含未解释的字节数组）和目录（包含对数据文件和其他目录的命名引用）。

## 10. 数据文件和目录

### 数据文件——“包含未解释的字节数组”

> **原文**：Data files (containing uninterpreted byte arrays) 
> **直译**：数据文件包含的是内核不进行解释的字节序列。

#### 1. 什么是“未解释” (Uninterpreted)？

这意味着 **操作系统内核（Kernel）根本不在乎文件里存的是什么**。

- **对于内核来说：** 所有的文件（无论是 `.c` 代码、`.txt` 文本、编译后的二进制程序、还是一张图片），在底层都只是一串 **0 和 1 的序列**（字节流）。内核不知道什么是换行符，不知道什么是像素点，也不知道什么是 CPU 指令。
    
- **对于用户程序来说：** 只有用户空间的程序（User Programs）才赋予这些字节意义。
    
    - `cat` 命令读取这串字节，把它解释为“字符”，画在屏幕上。
    - `gcc` 编译器读取这串字节，把它解释为“C 语言代码”。
    - `sh` (Shell) 读取这串字节，如果是脚本就解释执行，如果是二进制就加载运行。

#### 2. “字节数组” (Byte Arrays)

在 xv6 内部，一个文件就是一个**索引节点（Inode）加上一堆数据块（Blocks）**。 当你调用 `write(fd, "hello", 5)` 时，内核只是机械地把 `'h', 'e', 'l', 'l', 'o'` 这 5 个字节复制到磁盘的某个块上，然后记录一下“这个文件变长了 5 个字节”。内核不关心这 5 个字节代表什么。

**打个比方：** 操作系统就像快递公司。你寄一个箱子（文件），快递员（内核）只负责把箱子安全地存好、取出来。快递员**不打开箱子**，也不在乎里面装的是蛋糕还是炸弹，对他来说，那只是“一个重 2kg 的物体”（字节数组）。

### 目录——“包含对数据文件和其他目录的命名引用”

> 原文：Directories (containing named references to data files and other directories)
> 直译：目录包含的是“名字”到“文件实体”的映射关系。

#### 1. 目录本质上也是文件

在 xv6 中，目录**就是**一个特殊的文件。

- 它也有inode。
- 它也有数据块。
- 它也可以被读取（通过 `ls`）。

#### 2. “命名引用” (Named References) 是什么意思？

既然目录是文件，那它的数据块里存的是什么数据呢？

答案是：一张清单（List）。

这张清单的每一项都遵循一个特定的结构体 `struct dirent`（定义在 `kernel/fs.h`）：


```c
// kernel/fs.h
struct dirent {
  ushort inum;        // Inode Number (引用/实体)
  char name[DIRSIZ];  // File Name (命名/名字)
};
```

目录的数据块里，密密麻麻地排列着这种结构体。这就是所谓的“命名引用”：

- **命名 (Name)**：`name` 字段（例如 "home", "cat", "readme.txt"）。
- **引用 (Reference)**：`inum` 字段（例如 12, 45, 99）。

#### 3. 为什么叫“引用”？

因为文件真正的身体是 Inode（索引节点）。Inode 只有编号（比如 23 号），没有名字。

目录的作用就是把一个人类可读的字符串（"config"）和一个机器可读的编号（Inode 23）连接起来。

可视化理解：

假设你查看 / 根目录的内容，它的数据块里实际存的是这样的数据表：

|**inum (引用)**|**name (命名)**|**解释**|
|---|---|---|
|1|`.`|当前目录（指向自己）|
|1|`..`|父目录（根目录的父目录还是自己）|
|23|`readme`|指向 23 号 Inode (可能是个数据文件)|
|45|`home`|指向 45 号 Inode (可能是另一个目录)|
|12|`console`|指向 12 号 Inode (可能是设备文件)|

#### 4. “以及其他目录”

这句话提到的包含“其他目录”，指的就是文件系统的层级结构（树状结构）。

如果目录 A 里面有一条记录指向 Inode B，而 Inode B 的类型恰好也是“目录”，那么我们就形成了子目录结构。

## 11. 实例

```c
chdir("/a");
chdir("b");
open("c", O_RDONLY);
open("/a/b/c", O_RDONLY);
```

绝对路径以`/`开头表示根目录，相对路径直接写目录名。

创建新文件和目录的系统调用：
- `mkdir`创建一个新目录
- `open`中若使用`O_CREATE`标志将会创建一个新的数据文件
- `mknod`创建一个新的设备文件

这个例子说明了这三点:

```c
mkdir("/dir");
fd = open("/dir/file", O_CREATE | O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

`mknod`创建一个引用设备的特殊文件。与设备文件相关联的是主设备号和次设备号(`mknod`的两个参数)，它们唯一地标识了一个内核设备。

当进程稍后打开设备文件时，内核将使用内核设备实现`read`和`write`系统调用，而不是使用文件系统。


## 12. “一切皆文件”

上面那句话揭示了 UNIX/Linux/xv6 设计哲学中最精妙的一点：**“一切皆文件” (Everything is a file)** 的底层实现机制。

简单来说，这句话的意思是：**虽然你表面上是在操作一个文件（比如用 `write` 写数据），但内核在后台会偷偷把你的操作“劫持”，转交给硬件驱动程序去处理，而不是把数据存到硬盘的某个扇区里。**

**“普通文件”** 和 **“设备文件”** 在内核处理 `read`/`write` 时的不同流程：

### 1. 表面上的假象（用户视角）

在用户程序看来，它们没有任何区别。

- **写普通文件**：`fd = open("note.txt", ...); write(fd, "hello", 5);`
- **写设备文件**：`fd = open("console", ...); write(fd, "hello", 5);`

代码一模一样。用户程序只知道：“我往一个文件描述符里写了 5 个字节”。

### 2. 幕后的分流（内核视角）

当内核收到 `write()` 系统调用时，它会检查这个文件描述符对应的 **Inode（索引节点）** 的类型。这就是“分流”发生的地方。

#### 情景 A：如果是普通文件 (Normal File)

1. **内核判断**：`Inode.type` 是 `T_FILE`。
2. **走“文件系统”路线**：
    
    - 内核去查找这个文件在硬盘上占用了哪些**数据块 (Blocks)**。
    - 内核把 "hello" 这 5 个字节写入到磁盘的缓冲区。
    - 最终数据被持久化保存在**硬盘介质**上。
    - _这就是这句话里说的“use the file system”。_

#### 情景 B：如果是设备文件 (Device File)

1. **内核判断**：`Inode.type` 是 `T_DEVICE`。
2. **走“内核设备实现”路线**：
    
    - 内核**不再**去关心磁盘块、扇区、文件大小等文件系统的概念。
    - 内核查看这个 Inode 里的 **主设备号 (Major Device Number)**。
    - 假设主设备号是 `1`（代表控制台 Console）。
    - 内核通过查表（`devsw` 数组），找到主设备号 `1` 对应的**驱动程序写函数**（比如 `consolewrite`）。
    - 内核调用 `consolewrite("hello")`。
    - 该函数直接操作显卡或串口，把字符显示在屏幕上。
    - _这就是这句话里说的“diverts... to the kernel device implementation”。_

### 3. xv6 代码层面的证据

在 xv6 的内核代码 `kernel/file.c` 中，`filewrite` 函数清楚地展示了这个逻辑分支：

```c
// kernel/file.c

int filewrite(struct file *f, uint64 addr, int n) {
  
  // 分支 1：如果是设备文件
  if(f->type == FD_DEVICE){
    // "Divert" (转移) 到设备驱动的 write 函数
    // devsw 是设备交换表，f->major 是主设备号
    return devsw[f->major].write(1, addr, n); 
  } 
  
  // 分支 2：如果是普通文件 (Inodes)
  else if(f->type == FD_INODE){
    // 使用文件系统逻辑，写入磁盘块
    // ... (锁定 inode，调用 writei 等)
  }
  
  // ...
}
```

## 13. fstat：从文件描述符所引用的inode中检索信息

`fstat`系统调用从文件描述符所引用的inode中检索信息。它填充一个`stat`类型的结构体，`struct stat`在***stat.h(kernel/stat.h)***中定义为：

```c
#define T_DIR 1    // Directory
#define T_FILE 2   // File
#define T_DEVICE 3 // Device
struct stat {
    int dev;     // 文件系统的磁盘设备
    uint ino;    // Inode编号
    short type;  // 文件类型
    short nlink; // 指向文件的链接数
    uint64 size; // 文件字节数
};

```

## 14. `link`：创建另一个文件名

`link`系统调用创建另一个文件名，该文件名指向与现有文件相同的inode。下面的代码片段创建了一个名字既为**a**又为**b**的新文件：

```c
open("a", O_CREATE | O_WRONLY);
link("a", "b");

```

从**a**读取或写入与从**b**读取或写入是相同的操作。每个inode由唯一的inode编号标识。在上面的代码序列之后，可以通过检查`fstat`的结果来确定a和b引用相同的底层内容:两者都将返回相同的inode号(`ino`)，并且`nlink`计数将被设置为2。

`unlink`系统调用从文件系统中删除一个名称。只有当**文件的链接数为零**且**没有文件描述符引用**时，文件的inode和包含其内容的**磁盘空间才会被释放**。因此添加：

```c
unlink("a");
```

使得其仅可作为b访问。

此外，
```c
fd = open("/tmp/xyz", O_CREATE | O_RDWR);
unlink("/tmp/xyz");
```
是创建没有名称的临时inode的惯用方法，该临时inode将在进程关闭fd或退出时被清理。（回忆上面的unlink关闭条件）。

Unix以用户级程序的形式提供了可从shell调用的文件实用程序，例如`mkdir`、`ln`和`rm`。这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。事后看来，这个计划似乎是显而易见的，但是在Unix时代设计的其他系统经常将这样的命令构建到shell中(并将shell构建到内核中)。

一个例外是`cd`，它是内置在shell(**_user/sh.c_**:160)。`cd`必须更改shell本身的当前工作目录。如果`cd`作为常规命令运行，那么shell将分出一个子进程，子进程将运行`cd`，`cd`将更改子进程的工作目录。父目录(即shell的)的工作目录不会改变。

以下代码展示了cd命令的判断分支：

```c
while(getcmd(buf, sizeof(buf)) >= 0){

    char *cmd = buf;

    while (*cmd == ' ' || *cmd == '\t')

      cmd++;  // remove leading spaces

    if (*cmd == '\n') // is a blank command

      continue;

    if(cmd[0] == 'c' && cmd[1] == 'd' && cmd[2] == ' '){

      // Chdir must be called by the parent, not the child.

      cmd[strlen(cmd)-1] = 0;  // chop \n

      if(chdir(cmd+3) < 0)  // 调用chdir systemcall

        fprintf(2, "cannot cd %s\n", cmd+3);

    } else {

      if(fork1() == 0)

        runcmd(parsecmd(cmd));

      wait(0);

    }

  }
```

## 15. 深度解析inode

在 xv6 和类 Unix 系统中，**inode**（index node，索引节点）是文件系统的灵魂。如果把文件系统比作一本书，那么“文件名”只是书名，而 **inode 才是这本书真正的正文、页码和版权页**。

理解 inode，最关键的一点是：**文件名和文件内容是完全解耦的**。

---

### 1. inode 的本质：文件的“身份证”

在磁盘上，文件并不是一个连续的整体。一个文件由两部分组成：

- **元数据（Metadata）**：记录文件的属性（大小、类型、权限等）。这就是 **inode**。
    
- **数据块（Data Blocks）**：记录文件的实际内容（比如你写的代码、存的图片）。
    

**每个文件有且仅有一个 inode**。在内核中，inode 用一个唯一的数字标识，称为 **inumber**。

---

### 2. inode 里到底存了什么？

你可以查看 xv6 源码中的 `kernel/fs.h`，一个典型的磁盘 inode（`struct dinode`）包含以下信息：

- **Type (文件类型)**：是普通文件、目录，还是设备文件？
    
- **nlink (硬链接数)**：有多少个文件名指向这个 inode。
    
- **Size (文件大小)**：文件共有多少个字节。
    
- **Addrs (数据块指针)**：这是最重要的部分。它是一个数组，记录了文件内容存放在磁盘的哪些块（blocks）上。
    

> **注意**：**inode 里面不包含文件名！** 文件名存放在“目录文件”的数据块里。这就是为什么你可以为同一个文件创建多个硬链接（不同的文件名，指向同一个 inode）。

---

### 3. inode 是如何找到数据的？（索引机制）

xv6 的 inode 使用了**直接索引**和**一级间接索引**的混合模式：

1. **直接索引 (Direct Blocks)**：`addrs` 数组的前 12 个元素直接存放磁盘块号。如果文件很小（小于 12×1024 字节），直接通过这些块号就能找到数据。
    
2. **间接索引 (Indirect Block)**：第 13 个元素指向一个“索引块”。这个块本身不存文件内容，而是存了 256 个其他的块号。
    

这种设计让 inode 既能快速访问小文件，又能支持足够大的大文件。

---

### 4. inode 的生命周期：磁盘 vs 内存

在 xv6 中，inode 存在两种形态：

- **dinode (on-disk)**：持久化存储在磁盘的“inode 区”。当你重启电脑，它依然在那里。
    
- **inode (in-memory)**：当内核需要操作某个文件时，会把磁盘上的 `dinode` 读入内存，增加一些运行时的信息（比如 `ref` 引用计数、`lock` 锁），这被称为 **active inode**。
    

内核维护了一个 **inode cache (icache)**。当你调用 `open` 时，内核去 icache 里找；找不到再从磁盘读。

---

### 5. 为什么需要 inode？（设计的精妙之处）

如果你理解了 inode，很多 OS 的“玄学”问题就迎刃而解了：

- **移动文件为什么快？**：在同一个分区移动文件，只是在目录里改了下文件名和 inode 的对应关系，**inode 本身和数据块根本没动**。
    
- **文件删除了，为什么空间没释放？**：如果一个文件被删除了，但还有一个进程打开着它（引用计数不为 0），或者还有硬链接指向它（nlink > 0），内核就不会删除 inode 和数据块。只有当 `nlink == 0` 且 `ref == 0` 时，文件才真正消失。
    
- **什么是“坏道”？**：如果存储 inode 的那个磁盘块坏了，即便数据块是好的，你也找不回文件了，因为“索引”丢了。
    

### 总结

- **inode = 文件属性 + 数据块位置**。
    
- **文件名只是 inode 的一个别名**。
    
- **inumber 是文件在文件系统里的真正唯一标识**。