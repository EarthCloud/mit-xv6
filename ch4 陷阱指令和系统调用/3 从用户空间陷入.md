## 3. 用户空间陷阱如何发生

如果用户程序发出系统调用（`ecall`指令），或者做了一些非法的事情，或者设备中断，那么在用户空间中执行时就可能会产生陷阱。

来自用户空间的陷阱的高级路径是`uservec` (**_kernel/trampoline.S_**:16)，然后是`usertrap` (**_kernel/trap.c_**:37)；返回时，先是`usertrapret` (**_kernel/trap.c_**:90)，然后是`userret` (**_kernel/trampoline.S_**:16)。

来自用户代码的陷阱比来自内核的陷阱更具挑战性，因为`satp`指向不映射内核的用户页表，栈指针可能包含无效甚至恶意的值。

由于RISC-V硬件在陷阱期间不会切换页表，所以用户页表必须包括`uservec`（**stvec**指向的陷阱向量指令）的映射。`uservec`必须切换`satp`以指向内核页表；为了在切换后继续执行指令，`uservec`必须在内核页表中与用户页表中映射相同的地址。下面是`uservec`的具体实现：

```c
uservec:    

        # trap.c sets stvec to point here, so

        # traps from user space start here,

        # in supervisor mode, but with a

        # user page table.


        # save user a0 in sscratch so

        # a0 can be used to get at TRAPFRAME.

        csrw sscratch, a0

        # each process has a separate p->trapframe memory area,

        # but it's mapped to the same virtual address

        # (TRAPFRAME) in every process's user page table.

        li a0, TRAPFRAME

        # save the user registers in TRAPFRAME

        sd ra, 40(a0)

        sd sp, 48(a0)

        sd gp, 56(a0)

        sd tp, 64(a0)

        sd t0, 72(a0)

        sd t1, 80(a0)

        sd t2, 88(a0)

        sd s0, 96(a0)

        sd s1, 104(a0)

        sd a1, 120(a0)

        sd a2, 128(a0)

        sd a3, 136(a0)

        sd a4, 144(a0)

        sd a5, 152(a0)

        sd a6, 160(a0)

        sd a7, 168(a0)

        sd s2, 176(a0)

        sd s3, 184(a0)

        sd s4, 192(a0)

        sd s5, 200(a0)

        sd s6, 208(a0)

        sd s7, 216(a0)

        sd s8, 224(a0)

        sd s9, 232(a0)

        sd s10, 240(a0)

        sd s11, 248(a0)

        sd t3, 256(a0)

        sd t4, 264(a0)

        sd t5, 272(a0)

        sd t6, 280(a0)

        # save the user a0 in p->trapframe->a0

        csrr t0, sscratch

        sd t0, 112(a0)

        # initialize kernel stack pointer, from p->trapframe->kernel_sp

        ld sp, 8(a0)

        # make tp hold the current hartid, from p->trapframe->kernel_hartid

        ld tp, 32(a0)

        # load the address of usertrap(), from p->trapframe->kernel_trap

        ld t0, 16(a0)

        # fetch the kernel page table address, from p->trapframe->kernel_satp.

        ld t1, 0(a0)

        # wait for any previous memory operations to complete, so that

        # they use the user page table.

        sfence.vma zero, zero

  

        # install the kernel page table.

        csrw satp, t1

  

        # flush now-stale user entries from the TLB.

        sfence.vma zero, zero

  

        # call usertrap()

        jalr t0
```

## 4. uservec

xv6使用包含`uservec`的蹦床页面（trampoline page）来满足这些约束。xv6将蹦床页面映射到内核页表和每个用户页表中相同的虚拟地址。这个虚拟地址是`TRAMPOLINE`（如图2.3和图3.3所示）。蹦床内容在trampoline.S中设置，并且（当执行用户代码时）`stvec`设置为`uservec` (**_kernel/trampoline.S_**:16)。

当`uservec`启动时，所有32个寄存器都包含被中断代码所拥有的值。但是`uservec`需要能够修改一些寄存器，以便设置`satp`并生成保存寄存器的地址。RISC-V以`sscratch`寄存器的形式提供了帮助。`uservec`开始时的`csrrw`指令交换了`a0`和`sscratch`的内容。现在用户代码的`a0`被保存了；`uservec`有一个寄存器（`a0`）可以使用；`a0`包含内核以前放在`sscratch`中的值，如以下语句所示：

```c
        # save user a0 in sscratch so

        # a0 can be used to get at TRAPFRAME.

        csrw sscratch, a0
```

这里使用li加载立即数TRAPFRAME到a0中，这样就可以使用a0的地址加偏移量来存储值：

```c
        # each process has a separate p->trapframe memory area,

        # but it's mapped to the same virtual address

        # (TRAPFRAME) in every process's user page table.

        li a0, TRAPFRAME
```

`uservec`的下一个任务是保存用户寄存器。在进入用户空间之前，内核先前将`sscratch`设置为指向该进程的陷阱帧（每个进程都保留自己的陷阱帧），该帧（除此之外）具有保存所有用户寄存器的空间(**_kernel/proc.h_**:44)。因为`satp`仍然指向用户页表，所以`uservec`需要将陷阱帧映射到用户地址空间中。每当创建一个进程时，xv6就为该进程的陷阱帧分配一个页面，并安排它始终映射在用户虚拟地址`TRAPFRAME`，该地址就在`TRAMPOLINE`下面。尽管使用物理地址，该进程的`p->trapframe`仍指向陷阱帧，这样内核就可以通过内核页表使用它。

陷阱帧的定义如下（前面的整数是它的偏移量）：

```c
struct trapframe {

  /*   0 */ uint64 kernel_satp;   // kernel page table

  /*   8 */ uint64 kernel_sp;     // top of process's kernel stack

  /*  16 */ uint64 kernel_trap;   // usertrap()

  /*  24 */ uint64 epc;           // saved user program counter

  /*  32 */ uint64 kernel_hartid; // saved kernel tp

  /*  40 */ uint64 ra;

  /*  48 */ uint64 sp;

  /*  56 */ uint64 gp;

  /*  64 */ uint64 tp;

  /*  72 */ uint64 t0;

  /*  80 */ uint64 t1;

  /*  88 */ uint64 t2;

  /*  96 */ uint64 s0;

  /* 104 */ uint64 s1;

  /* 112 */ uint64 a0;

  /* 120 */ uint64 a1;

  /* 128 */ uint64 a2;

  /* 136 */ uint64 a3;

  /* 144 */ uint64 a4;

  /* 152 */ uint64 a5;

  /* 160 */ uint64 a6;

  /* 168 */ uint64 a7;

  /* 176 */ uint64 s2;

  /* 184 */ uint64 s3;

  /* 192 */ uint64 s4;

  /* 200 */ uint64 s5;

  /* 208 */ uint64 s6;

  /* 216 */ uint64 s7;

  /* 224 */ uint64 s8;

  /* 232 */ uint64 s9;

  /* 240 */ uint64 s10;

  /* 248 */ uint64 s11;

  /* 256 */ uint64 t3;

  /* 264 */ uint64 t4;

  /* 272 */ uint64 t5;

  /* 280 */ uint64 t6;

};
```

因此在交换`a0`和`sscratch`之后，`a0`持有指向当前进程陷阱帧的指针。`uservec`现在保存那里的所有用户寄存器，包括从`sscratch`读取的用户的`a0`。

```c
        # save the user registers in TRAPFRAME

        sd ra, 40(a0)

        sd sp, 48(a0)

        sd .........

        sd t6, 280(a0)

  

        # save the user a0 in p->trapframe->a0

        csrr t0, sscratch

        sd t0, 112(a0)
```

陷阱帧包含指向当前进程内核栈的指针、当前CPU的`hartid`、`usertrap`的地址和内核页表的地址。`uservec`取得这些值，将`satp`切换到内核页表，并调用`usertrap`：

```c

        # initialize kernel stack pointer, from p->trapframe->kernel_sp

        ld sp, 8(a0)

        # make tp hold the current hartid, from p->trapframe->kernel_hartid

        ld tp, 32(a0)

        # load the address of usertrap(), from p->trapframe->kernel_trap

        ld t0, 16(a0)

        # fetch the kernel page table address, from p->trapframe->kernel_satp.

        ld t1, 0(a0)

        # wait for any previous memory operations to complete, so that

        # they use the user page table.

        sfence.vma zero, zero

        # install the kernel page table.

        csrw satp, t1

        # flush now-stale user entries from the TLB.

        sfence.vma zero, zero

        # call usertrap()

        jalr t0
```


## 5. usertrap

`usertrap`的任务是确定陷阱的原因，处理并返回(**_kernel/trap.c_**:37):

```c
//

// handle an interrupt, exception, or system call from user space.

// called from, and returns to, trampoline.S

// return value is user satp for trampoline.S to switch to.

//

uint64

usertrap(void)

{

  int which_dev = 0;
  
  if((r_sstatus() & SSTATUS_SPP) != 0)

    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),

  // since we're now in the kernel.

  w_stvec((uint64)kernelvec);  //DOC: kernelvec

  struct proc *p = myproc();

  // save user program counter.

  p->trapframe->epc = r_sepc();

  if(r_scause() == 8){

    // system call

    if(killed(p))

      kexit(-1);

    // sepc points to the ecall instruction,

    // but we want to return to the next instruction.

    p->trapframe->epc += 4;

    // an interrupt will change sepc, scause, and sstatus,

    // so enable only now that we're done with those registers.

    intr_on();

    syscall();

  } else if((which_dev = devintr()) != 0){

    // ok

  } else if((r_scause() == 15 || r_scause() == 13) &&

            vmfault(p->pagetable, r_stval(), (r_scause() == 13)? 1 : 0) != 0) {

    // page fault on lazily-allocated page

  } else {

    printf("usertrap(): unexpected scause 0x%lx pid=%d\n", r_scause(), p->pid);

    printf("            sepc=0x%lx stval=0x%lx\n", r_sepc(), r_stval());

    setkilled(p);

  }

  if(killed(p))

    kexit(-1);

  // give up the CPU if this is a timer interrupt.

  if(which_dev == 2)

    yield();

  prepare_return();

  // the user page table to switch to, for trampoline.S

  uint64 satp = MAKE_SATP(p->pagetable);

  // return to trampoline.S; satp value in a0.

  return satp;

}
```

如上所述，它首先改变`stvec`，这样内核中的陷阱将由`kernelvec`处理：

```c
  // send interrupts and exceptions to kerneltrap(),

  // since we're now in the kernel.

  w_stvec((uint64)kernelvec);  //DOC: kernelvec
```

它保存了`sepc`（保存的用户程序计数器），再次保存是因为`usertrap`中可能有一个进程切换，可能导致`sepc`被覆盖：

```c
  struct proc *p = myproc();

  // save user program counter.

  p->trapframe->epc = r_sepc();
```

如果陷阱来自系统调用，`syscall`会处理它；如果是设备中断，`devintr`会处理；否则它是一个异常，内核会杀死错误进程，分发指令如下：

```c
  if(r_scause() == 8){

    // system call

    if(killed(p))

      kexit(-1);

    // sepc points to the ecall instruction,

    // but we want to return to the next instruction.

    p->trapframe->epc += 4;

    // an interrupt will change sepc, scause, and sstatus,

    // so enable only now that we're done with those registers.

    intr_on();
    
    syscall();

  } else if((which_dev = devintr()) != 0){

    // ok

  } else if((r_scause() == 15 || r_scause() == 13) &&

            vmfault(p->pagetable, r_stval(), (r_scause() == 13)? 1 : 0) != 0) {

    // page fault on lazily-allocated page

  } else {

    printf("usertrap(): unexpected scause 0x%lx pid=%d\n", r_scause(), p->pid);

    printf("            sepc=0x%lx stval=0x%lx\n", r_sepc(), r_stval());

    setkilled(p);

  }
```

以下是对这段代码中出现的，以及隐含的 `scause` 值的详细分析：

1. `r_scause() == 8`：系统调用 (Environment Call)

- **含义**：**用户态系统调用 (User mode environment call)**。
    
- **场景**：用户程序执行了 `ecall` 指令。这是用户程序向内核请求服务（如 `write`, `read`, `fork`）的唯一正规途径。
    
- **代码行为解析**：
    
    - `p->trapframe->epc += 4;`：**非常关键**。`epc` (Exception Program Counter) 记录的是发生 Trap 的那条指令的地址（即 `ecall` 的地址）。处理完系统调用后，我们希望返回到 `ecall` 的**下一条**指令继续执行，而不是重新执行 `ecall`（否则会死循环）。RISC-V 指令长度通常为 4 字节，所以加 4。
        
    - `intr_on();`：开启中断。系统调用通常是耗时的操作（比如读磁盘），开启中断可以让内核在处理系统调用的同时响应其他硬件中断（如时钟中断），提高并发效率。

2. `devintr() != 0`：设备中断 (Device Interrupt)

虽然代码里没直接写 `scause` 的值，但 `devintr()` 函数内部会检查 `scause` 的**最高位（Interrupt Bit）**。

- **含义**：**硬件设备请求关注**。
    
- **`scause` 的可能值**（最高位为 1，低位表示类型）：
    
    - **`0x8000...001L` (Supervisor software interrupt)**：内核软件中断（较少见，用于核间通信）。
    - **`0x8000...005L` (Supervisor timer interrupt)**：**时钟中断**。这是实现时间片轮转调度（Time Slicing）的基础，强迫 CPU 切换进程。
    - **`0x8000...009L` (Supervisor external interrupt)**：**外部中断**。来自 PLIC (Platform-Level Interrupt Controller)，代表键盘输入、UART 串口数据到达、或者磁盘读写完成。
        
- **代码行为**：如果 `devintr()` 返回非 0，说明是一个合法的硬件中断，内核已经处理完了（比如把字符放进了缓冲区），直接跳过后续逻辑。

 3. `r_scause() == 13` 或 `15`：缺页异常 (Page Fault)

这段代码显然经过了修改（用于 Lazy Allocation 实验），标准的 xv6 会直接杀掉这类进程。

- **`scause == 13` (Load Page Fault)**：
    
    - **含义**：**加载页面错误**。CPU 试图读取一个虚拟地址，但该地址在页表中无效（PTE_V 为 0）或权限不足（没有 Read 权限）。
        
    - **场景**：用户程序读了 `lazy allocation` 分配但还没映射物理页的内存。
        
- **`scause == 15` (Store/AMO Page Fault)**：
    
    - **含义**：**存储页面错误**。CPU 试图写入一个虚拟地址，但该地址无效或只读。
        
    - **场景**：用户程序写了 `lazy allocation` 的内存，或者写时复制（COW）页面。
        
- **代码行为**：
    
    - 调用 `vmfault()` 尝试“补救”。如果是 Lazy Allocation，`vmfault` 会分配物理页并建立映射。
        
    - `(r_scause() == 13) ? 1 : 0`：告诉 `vmfault` 这是一个读操作还是写操作（这在 COW 实验中很重要，Lazy Lab 中通常只需要地址）。

 4. `else`：未预期的 Trap (Unexpected Trap)

如果 `scause` 不是上面任何一种，说明发生了内核无法处理或不应发生的错误。

- **常见的“意外”值**：
    
    - **`scause == 12` (Instruction Page Fault)**：**指令页面错误**。程序跳到了一个无效的地址去取指（比如跳到了 0 地址或者乱码区域）。这是野指针最常见的后果之一。
        
    - **`scause == 2` (Illegal Instruction)**：**非法指令**。CPU 读到了一串它看不懂的二进制代码（通常是因为跳到了数据段去执行，或者编译出的指令集架构不对）。
        
    - **`scause == 4` (Load Address Misaligned)** / **`6` (Store Address Misaligned)**：**地址未对齐**。比如在需要 4 字节对齐的地址上读取数据，但地址却是奇数（RISC-V 硬件通常要求对齐，不过 QEMU 可能比较宽容）。
        
- **代码行为**：
    
    - 打印出错信息（PID、scause、sepc、stval）。
        
    - `setkilled(p)`：标记杀死进程。这是保护系统的最后一道防线，防止出错的进程破坏系统。

在退出的过程中，`usertrap`检查进程是已经被杀死还是应该让出CPU（如果这个陷阱是计时器中断）：

```c
  if(killed(p))

    kexit(-1);

  

  // give up the CPU if this is a timer interrupt.

  if(which_dev == 2)

    yield();

```

## 6. 返回用户空间

返回用户空间的第一步是调用`usertrapret` (**_kernel/trap.c_**:90)，在目前版本的代码中，usertrap调用了`prepare_return`函数，该函数设置RISC-V控制寄存器，为将来来自用户空间的陷阱做准备。：

```c
//

// set up trapframe and control registers for a return to user space

//

void

prepare_return(void)

{

  struct proc *p = myproc();

  

  // we're about to switch the destination of traps from

  // kerneltrap() to usertrap(). because a trap from kernel

  // code to usertrap would be a disaster, turn off interrupts.

  intr_off();

  

  // send syscalls, interrupts, and exceptions to uservec in trampoline.S

  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);

  w_stvec(trampoline_uservec);

  

  // set up trapframe values that uservec will need when

  // the process next traps into the kernel.

  p->trapframe->kernel_satp = r_satp();         // kernel page table

  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack

  p->trapframe->kernel_trap = (uint64)usertrap;

  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()

  

  // set up the registers that trampoline.S's sret will use

  // to get to user space.

  // set S Previous Privilege mode to User.

  unsigned long x = r_sstatus();

  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode

  x |= SSTATUS_SPIE; // enable interrupts in user mode

  w_sstatus(x);

  

  // set S Exception Program Counter to the saved user pc.

  w_sepc(p->trapframe->epc);

}
```

这涉及到将`stvec`更改为指向`uservec`，准备`uservec`所依赖的陷阱帧字段，并将`sepc`设置为之前保存的用户程序计数器。最后，`usertrapret`在用户和内核页表中都映射的蹦床页面上调用`userret`；原因是`userret`中的汇编代码会切换页表。

`usertrapret`对`userret`的调用将指针传递到`a0`中的进程用户页表和`a1`中的`TRAPFRAME` (**_kernel/trampoline.S_**:88)，`userret`将`satp`切换到进程的用户页表。回想一下，用户页表同时映射蹦床页面和`TRAPFRAME`，但没有从内核映射其他内容，同样，蹦床页面映射在用户和内核页表中的同一个虚拟地址上的事实允许用户在更改`satp`后继续执行：

```Assembly
        # usertrap() returns here, with user satp in a0.

        # return from kernel to user.

  

        # switch to the user page table.

        sfence.vma zero, zero

        csrw satp, a0

        sfence.vma zero, zero

  

        li a0, TRAPFRAME
```

`userret`复制陷阱帧保存的用户`a0`到`sscratch`，为以后与`TRAPFRAME`的交换做准备。从此刻开始，`userret`可以使用的唯一数据是寄存器内容和陷阱帧的内容：

```c
# restore all but a0 from TRAPFRAME

        ld ra, 40(a0)

        ld sp, 48(a0)

        ld .........

        ld t6, 280(a0)
```

下一个`userret`从陷阱帧中恢复保存的用户寄存器，做`a0`与`sscratch`的最后一次交换来恢复用户`a0`并为下一个陷阱保存`TRAPFRAME`，并使用`sret`返回用户空间：

```c
        # restore user a0

        ld a0, 112(a0)

        # return to user mode and user pc.

        # usertrapret() set up sstatus and sepc.

        sret
```

