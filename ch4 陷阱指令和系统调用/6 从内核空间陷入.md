## 10. 内核陷阱的执行过程

xv6根据执行的是用户代码还是内核代码，对CPU陷阱寄存器的配置有所不同。

当在CPU上执行内核时，内核将`stvec`指向`kernelvec`(**_kernel/kernelvec.S_**:10)的汇编代码，由于xv6已经在内核中，`kernelvec`可以依赖于设置为内核页表的`satp`，以及指向有效内核栈的栈指针。`kernelvec`保存所有寄存器，以便被中断的代码最终可以不受干扰地恢复：

```c

.globl kernelvec

.align 4

kernelvec:

        // make room to save registers.

        addi sp, sp, -256

  

        // save the registers.

        sd ra, 0(sp)

        sd sp, 8(sp)

        sd gp, 16(sp)

        sd tp, 24(sp)

        sd t0, 32(sp)

        sd t1, 40(sp)

        sd t2, 48(sp)

        sd s0, 56(sp)

        sd s1, 64(sp)

        sd a0, 72(sp)

        sd a1, 80(sp)

        sd a2, 88(sp)

        sd a3, 96(sp)

        sd a4, 104(sp)

        sd a5, 112(sp)

        sd a6, 120(sp)

        sd a7, 128(sp)

        sd s2, 136(sp)

        sd s3, 144(sp)

        sd s4, 152(sp)

        sd s5, 160(sp)

        sd s6, 168(sp)

        sd s7, 176(sp)

        sd s8, 184(sp)

        sd s9, 192(sp)

        sd s10, 200(sp)

        sd s11, 208(sp)

        sd t3, 216(sp)

        sd t4, 224(sp)

        sd t5, 232(sp)

        sd t6, 240(sp)

  

        // call the C trap handler in trap.c

        call kerneltrap

  

        // restore registers.

        ld ra, 0(sp)

        ld sp, 8(sp)

        ld gp, 16(sp)

        // not this, in case we moved CPUs: ld tp, 24(sp)

        ld t0, 32(sp)

        ld t1, 40(sp)

        ld t2, 48(sp)

        ld s0, 56(sp)

        ld s1, 64(sp)

        ld a0, 72(sp)

        ld a1, 80(sp)

        ld a2, 88(sp)

        ld a3, 96(sp)

        ld a4, 104(sp)

        ld a5, 112(sp)

        ld a6, 120(sp)

        ld a7, 128(sp)

        ld s2, 136(sp)

        ld s3, 144(sp)

        ld s4, 152(sp)

        ld s5, 160(sp)

        ld s6, 168(sp)

        ld s7, 176(sp)

        ld s8, 184(sp)

        ld s9, 192(sp)

        ld s10, 200(sp)

        ld s11, 208(sp)

        ld t3, 216(sp)

        ld t4, 224(sp)

        ld t5, 232(sp)

        ld t6, 240(sp)

  

        addi sp, sp, 256

  

        // return to whatever we were doing in the kernel.

        sret
```

`kernelvec`将寄存器保存在被中断的内核线程的栈上，这是有意义的，因为寄存器值属于该线程。如果陷阱导致切换到不同的线程，那这一点就显得尤为重要——在这种情况下，陷阱将实际返回到新线程的栈上，将被中断线程保存的寄存器安全地保存在其栈上：

```c
        // make room to save registers.

        addi sp, sp, -256

  

        // save the registers.

        sd ra, 0(sp)
		
		sd ..........
        
        sd t5, 232(sp)

        sd t6, 240(sp)
```

`Kernelvec`在保存寄存器后跳转到`kerneltrap`(**_kernel/trap.c_**:134)。

```c
        // call the C trap handler in trap.c

        call kerneltrap
```

## 11. kerneltrap的处理

`kerneltrap`为两种类型的陷阱做好了准备：设备中断和异常。它调用`devintr`(**_kernel/trap.c_**:177)来检查和处理前者。如果陷阱不是设备中断，则必定是一个异常，内核中的异常将是一个致命的错误；内核调用`panic`并停止执行：

```c
// interrupts and exceptions from kernel code go here via kernelvec,

// on whatever the current kernel stack is.

void

kerneltrap()

{

  int which_dev = 0;

  uint64 sepc = r_sepc();

  uint64 sstatus = r_sstatus();

  uint64 scause = r_scause();

  if((sstatus & SSTATUS_SPP) == 0)

    panic("kerneltrap: not from supervisor mode");

  if(intr_get() != 0)

    panic("kerneltrap: interrupts enabled");

  

  if((which_dev = devintr()) == 0){

    printf("scause %p\n", scause);

    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());

    panic("kerneltrap");

  }

  // ........

}
```

如果由于计时器中断而调用了`kerneltrap`，并且一个进程的内核线程正在运行（而不是调度程序线程），`kerneltrap`会调用`yield`，给其他线程一个运行的机会。在某个时刻，其中一个线程会让步，让我们的线程和它的`kerneltrap`再次恢复。第7章解释了`yield`中发生的事情：

```c
  // give up the CPU if this is a timer interrupt.

  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)

    yield();

```

当`kerneltrap`的工作完成后，它需要返回到任何被陷阱中断的代码。因为一个`yield`可能已经破坏了保存的`sepc`和在`sstatus`中保存的前一个状态模式，因此`kerneltrap`在启动时保存它们。它现在恢复这些控制寄存器并返回到`kernelvec`(**_kernel/kernelvec.S_**:48)：

```c
// interrupts and exceptions from kernel code go here via kernelvec,

// on whatever the current kernel stack is.

void

kerneltrap()

{

  // ........
  
  // the yield() may have caused some traps to occur,

  // so restore trap registers for use by kernelvec.S's sepc instruction.

  w_sepc(sepc);

  w_sstatus(sstatus);

}
```

`kernelvec`从栈中弹出保存的寄存器并执行`sret`，将`sepc`复制到`pc`并恢复中断的内核代码：

```c
        // restore registers.

        ld ra, 0(sp)

        ld sp, 8(sp)

        ld gp, 16(sp)

        // not this, in case we moved CPUs: ld tp, 24(sp)

        ld t0, 32(sp)

        ld .........

        ld t5, 232(sp)

        ld t6, 240(sp)
        
        addi sp, sp, 256

        // return to whatever we were doing in the kernel.

        sret
```

值得思考的是，如果内核陷阱由于计时器中断而调用`yield`，陷阱返回是如何发生的。

我们可以把`yield`看作一个漫长的、会暂停的函数调用。它会保存当前进程的上下文，直至其他进程让出CPU回到该进程。我们此时不必考虑下图中调用过程的具体实现，只需明确，`kerneltrap` 里的 `yield` 调用并不是一条不归路，当它返回时，代码逻辑自然会流动到 `kerneltrap` 的末尾，完成陷阱返回。

```text
kerneltrap()
  |
  +-> yield()
        |
        +-> sched()
              |
              +-> swtch()  <-- 1. 保存当前状态 (P->context)
                               2. 载入调度器状态
                                  ... (CPU 去跑别的进程了) ...
                                  ... (很久以后，调度器又选了 P) ...
                               3. 别人调用 swtch() 切换回 P
                               4. 恢复 P 的状态 (从 P->context)
              |
              +-> swtch 返回
        |
        +-> sched 返回
  |
  +-> yield 返回
  |
  +-> 恢复陷阱帧 (trapframe)
  +-> sret (回到用户空间或内核空间断点)
```

## 12. 在设置陷阱时取消中断

当CPU从用户空间进入内核时，xv6将CPU的`stvec`设置为`kernelvec`；您可以在`usertrap`(**_kernel/trap.c_**:29)中看到这一点：

```c
// set up to take exceptions and traps while in the kernel.

void

trapinithart(void)

{

  w_stvec((uint64)kernelvec);

}
```

在内核执行设置过程时，有一个时间窗口，此时`stvec`仍然为`uservec`，因此，在该窗口中**禁用设备中断**至关重要。

幸运的是，RISC-V总是在开始设置陷阱时禁用中断，xv6在设置`stvec`之前不会再次启用中断。这个过程由**硬件保证**，具体是依靠`sstatus` 寄存器的 **SIE** (Supervisor Interrupt Enable) 位，如果内核清空**SIE**，RISC-V将推迟设备中断，直到内核重新设置**SIE**。

一旦发生 Trap（无论是系统调用、异常还是设备中断），RISC-V 硬件会**原子地（Atomic）** 执行以下一连串动作，中间不允许插入任何其他指令：

1. **保存当前中断状态**：将当前的 `sstatus.SIE` 的值复制到 `sstatus.SPIE` (Previous Interrupt Enable)。
2. **强制关闭中断**：**将 `sstatus.SIE` 设置为 0**。
3. **跳转**：PC 跳转到 `stvec` 指向的地址（即 `uservec`）。
4. **切换模式**：CPU 权限提升到 Supervisor Mode。

由此确保了从用户空间的陷入过程的安全性。