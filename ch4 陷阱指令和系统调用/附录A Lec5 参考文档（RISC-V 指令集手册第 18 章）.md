由 Google Gemini 3 翻译，需要在学习Lec 5前完成该篇内容的阅读。

### 第 18 章：调用约定 (Calling Convention)

本章描述了 RV32 和 RV64 程序的 C 编译器标准以及两种调用约定：基于基础 ISA 加上标准通用扩展（RV32G/RV64G）的约定，以及针对缺乏浮点单元的实现（如 RV32I/RV64I）的软浮点约定 。具有 ISA 扩展的实现可能需要扩展的调用约定 。

#### 18.1 C 数据类型与对齐 (C Datatypes and Alignment)

表 18.1 总结了 RISC-V C 程序原生支持的数据类型 。

- **整数类型：** 在 RV32 和 RV64 的 C 编译器中，C 类型 `int` 均为 **32 位**宽 。
    
- **长整型与指针：** `long` 和指针 (`pointer`) 的宽度与整数寄存器一致。因此在 RV32 中，两者均为 32 位宽；而在 RV64 中，两者均为 64 位宽 。换句话说，RV32 采用 **ILP32** 整数模型，而 RV64 采用 **LP64** 模型 。
    
- **其他类型：** 在 RV32 和 RV64 中，C 类型 `long long` 是 64 位整数，`float` 是 32 位 IEEE 754-2008 浮点数，`double` 是 64 位 IEEE 754-2008 浮点数，`long double` 是 128 位 IEEE 浮点数 。
    
- **字符与短整型：**
    
    - C 类型 `char` 和 `unsigned char` 是 8 位无符号整数，存储在 RISC-V 整数寄存器时进行**零扩展** (zero-extended) 。
        
    - `unsigned short` 是 16 位无符号整数，存储在寄存器时进行**零扩展**[^1] 。
        
    - `signed char` 是 8 位有符号整数，存储在寄存器时进行**符号扩展** (sign-extended) [^2]。
        
    - `short` 是 16 位有符号整数，存储在寄存器时进行**符号扩展** 。
        
- **RV64 特殊规则：** 在 RV64 中，32 位类型（如 `int`）存储在整数寄存器时，必须是其 32 位值的**正确符号扩展** 。也就是说，第 63 到 31 位必须全部相等。**即使对于无符号的 32 位类型，这一限制也依然成立** 。

**表 18.1：基础 RISC-V ISA 的 C 编译器数据类型**


|**C 类型**|**描述**|**RV32 字节数**|**RV64 字节数**|
|---|---|---|---|
|`char`|字符值/字节|1|1|
|`short`|短整数|2|2|
|`int`|整数|4|4|
|`long`|长整数|4|**8**|
|`long long`|长长整数|8|8|
|`void*`|指针|4|**8**|
|`float`|单精度浮点|4|4|
|`double`|双精度浮点|8|8|
|`long double`|扩展精度浮点|16|16|

RV32 和 RV64 的 C 编译器及兼容软件在将上述所有数据类型存储在内存中时，均保持**自然对齐** (naturally aligned) 。

---

#### 18.2 RVG 调用约定 (RVG Calling Convention)

RISC-V 调用约定尽可能通过寄存器传递参数 。为此使用了最多 8 个整数寄存器 **`a0-a7`** 和最多 8 个浮点寄存器 **`fa0-fa7`** 。

- **结构体参数：** 如果函数的参数被概念化为 C 结构体的字段（每个字段具有指针级对齐），那么参数寄存器就是该结构体前 8 个指针字 (pointer-words) 的影子 。
    
- **浮点参数：** 如果第 $i < 8$ 个参数是浮点类型，它将通过浮点寄存器 `fai` 传递 ；否则，它通过整数寄存器 `ai` 传递。
    
    - _例外：_ 属于联合体 (union) 或结构体数组字段的浮点参数，通过**整数寄存器**传递 。
        
    - _可变参数：_ 可变参数函数中的浮点参数（除了参数列表中显式命名的那些）也通过**整数寄存器**传递 。
        
- **小参数与栈：** 小于一个指针字长的参数传递在参数寄存器的最低有效位中 。相应地，通过栈传递的“次指针字长” (sub-pointer-word) 参数出现在指针字的低地址处，因为 RISC-V 使用小端序内存系统 。
    
- **两倍字长参数的对齐：**
    
    - 当大小为指针字长两倍的原语参数通过栈传递时，它们保持自然对齐 。
        
    - 当它们通过整数寄存器传递时，必须驻留在**对齐的偶数-奇数寄存器对**中，其中偶数寄存器保存最低有效位 。
        
    - _RV32 示例：_ 函数 `void foo(int, long long)`，第一个参数传入 `a0`，第二个参数（64位）传入 `a2` 和 `a3` 。**`a1` 中不传递任何内容** 。
        
- **超大参数：** 大于指针字长两倍的参数通过**引用**传递 。
    
- **栈传递：** 概念结构体中未通过寄存器传递的部分通过栈传递 。栈指针 **`sp`** 指向第一个未在寄存器中传递的参数 。
    
- **返回值：**
    
    - 函数通过整数寄存器 **`a0`** 和 **`a1`** 以及浮点寄存器 **`fa0`** 和 **`fa1`** 返回值 。
        
    - 只有当浮点值是原语，或是仅由一个或两个浮点值组成的结构体的成员时，才通过浮点寄存器返回 。
        
    - 其他适合两个指针字大小的返回值通过 `a0` 和 `a1` 返回 。
        
    - 更大的返回值完全在内存中传递；调用者分配此内存区域，并将指向它的指针作为隐式的第一个参数传递给被调用者 。
        

**栈规则与寄存器保存责任：**

- **栈对齐：** 在标准 RISC-V 调用约定中，栈向**下**生长，且栈指针 (`sp`) 始终保持 **16 字节对齐** 。
    
- **调用者保存 (Caller-Saved / Temporary)：** 除了参数和返回值寄存器外，7 个整数寄存器 **`t0-t6`** 和 12 个浮点寄存器 **`ft0-ft11`** 是临时寄存器。它们在调用之间是**易失的 (volatile)**[^3]，如果调用者后续需要使用，**必须由调用者保存** 。
    
- **被调用者保存 (Callee-Saved / Preserved)：** 12 个整数寄存器 **`s0-s11`** 和 12 个浮点寄存器 **`fs0-fs11`** 在调用之间是**保留的 (preserved)**[^4]，如果被调用者使用了它们，**必须由被调用者保存** 。
    

**表 18.2：RISC-V 调用约定寄存器用途**

| **寄存器** | **ABI 名称** | **描述**                          | **保存者 (Saver)**   |
| ------- | ---------- | ------------------------------- | ----------------- |
| x0      | `zero`     | 硬连线零值                           | -                 |
| x1      | `ra`       | 返回地址 (Return address)           | **Caller** (调用者)  |
| x2      | `sp`       | 栈指针 (Stack pointer)             | **Callee** (被调用者) |
| x3      | `gp`       | 全局指针 (Global pointer)           | -                 |
| x4      | `tp`       | 线程指针 (Thread pointer)           | -                 |
| x5-7    | `t0-2`     | 临时寄存器 (Temporaries)             | **Caller**        |
| x8      | `s0/fp`    | 保存寄存器/帧指针 (Saved/Frame pointer) | **Callee**        |
| x9      | `s1`       | 保存寄存器                           | **Callee**        |
| x10-11  | `a0-1`     | 函数参数 / 返回值                      | **Caller**        |
| x12-17  | `a2-7`     | 函数参数                            | **Caller**        |
| x18-27  | `s2-11`    | 保存寄存器                           | **Callee**        |
| x28-31  | `t3-6`     | 临时寄存器                           | **Caller**        |
| f0-7    | `ft0-7`    | 浮点临时寄存器                         | **Caller**        |
| f8-9    | `fs0-1`    | 浮点保存寄存器                         | **Callee**        |
| f10-11  | `fa0-1`    | 浮点参数 / 返回值                      | **Caller**        |
| f12-17  | `fa2-7`    | 浮点参数                            | **Caller**        |
| f18-27  | `fs2-11`   | 浮点保存寄存器                         | **Callee**        |
| f28-31  | `ft8-11`   | 浮点临时寄存器                         | **Caller**        |

---

#### 18.3 软浮点调用约定 (Soft-Float Calling Convention)

软浮点调用约定用于缺乏浮点硬件的 RV32 和 RV64 实现 。它避免使用 F、D 和 Q 标准扩展中的所有指令，因此也不使用 `f` 寄存器 。

- **规则：** 整数参数的传递和返回方式与 RVG 约定相同，栈规则也相同 。浮点参数通过**整数寄存器**传递和返回，使用与同尺寸整数参数相同的规则 。
    
- **RV32 示例：** 函数 `double foo(int, double, long double)`：
    
    - 第一个参数 (`int`) 传入 `a0`。
        
    - 第二个参数 (`double`) 传入 `a2` 和 `a3`。
        
    - 第三个参数 (`long double`) 通过引用经由 `a4` 传递 。
        
    - 结果在 `a0` 和 `a1` 中返回。
        
- **RV64 示例：** 同样的函数：
    
    - 参数分别传入 `a0`, `a1`, 和 `a2-a3` 对。
        
    - 结果在 `a0` 中返回 。
        
- 动态舍入模式和累计异常标志通过 C99 头文件 `fenv.h` 提供的例程进行访问 。


### 脚注

[^1]: 无论最高位是什么，所有多出来的高位都用 **0** 填充，通常用于 **无符号数 (Unsigned Integers)** 。因为无符号数只表示数值的大小，前面补 0 不会改变它原本的值。

[^2]: 所有多出来的高位都用 **原始数据的最高位（即符号位）** 来填充 。通常用于 **有符号数 (Signed Integers)** 。这是为了在 **补码 (Two's Complement)** 表示法下保持数值不变。

[^3]: 当调用一个函数（Callee）后，回来时，这些寄存器里的值可能已经变了（被 Callee 改写了）。

[^4]: 无论调用的函数（Callee）在内部做了什么，回来时，这些寄存器里的值**必须**和调用前一模一样。
