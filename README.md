# lab3 pgtbl

在本实验中，我们将使用进程隔离的内核页表来加速解引用用户空间虚拟地址的过程。具体实现上，我们将为每个用户进程维护一个内核页表，并在内核态下使用该页表来解引用用户空间虚拟地址。这样，我们就可以避免频繁地切换页表，从而提高系统的性能。

## vmprint

在这个实验中，我们将实现一个名为 `vmprint` 的函数，用于打印当前进程的内核页表。该函数将遍历当前进程的内核页表，并打印出每个页表项的PTE和里地址。具体过程请参考[vmprint](./notes/1%20Print%20a%20page%20table.md)

你需要完成：

1. 理解内核页表的结构和工作原理。
2. 详细阅读RISC-V的页表机制，特别是Sv39模式下的页表结构。
3. 阅读walk等函数，了解软件如何实现页表的遍历和地址转换。
4. 实现 `vmprint` 函数，遍历当前进程的内核页表，并打印出每个页表项的PTE和里地址。

## A kernel page table per process

这个要求我们为每个用户进程维护一个内核页表。这意味着我们需要在进程创建时为其分配一个新的内核页表，并在进程切换时切换到相应的内核页表。具体实现细节请参考[A kernel page table per process](./notes/2%20A%20kernel%20page%20table%20per%20process.md)

你需要完成：
1. 了解内核虚拟地址空间的布局。
2. 详细了解内核是如何初始化内核页表、寄存器和内核栈的。
3. 对于这样的修改，使用细粒度的Git提交并在提交信息中详细描述你的修改内容，会有助于你更好地完成实验。
4. 彻底和深入地理解寻址过程，包括虚拟地址如何通过内核页表转换为物理地址，以及在内核态下如何使用这些地址进行访问。
5. 学习xv6页表和映射的释放机制，确保在进程退出时正确地释放内核页表资源。
6. 保持耐心，接受一个蠢错误导致的漫长调试过程。

## Simplify copyin/copyinstr

在这个实验中，我们将简化 `copyin` 和 `copyinstr` 函数的实现，使其能够直接使用当前进程的内核页表来解引用用户空间虚拟地址。这样，我们就可以避免频繁地切换页表，从而提高系统的性能。具体实现细节请参考[Simplify copy](./notes/3%20Simplify%20copy.md)

你需要完成：
1. 了解 `copyin` 和 `copyinstr` 函数的作用和实现细节。
2. 学习页表条目是如何被复制的。
3. 详细了解fork,exec和sbrk系统调用的实现过程。
4. 保持你在完成上个实验的耐心和决心，一点披头士的音乐可能会对这个过程有帮助（至少对我如此）。
