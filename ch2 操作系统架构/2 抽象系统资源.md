## 2. 再一步探讨：操作系统到底做了什么 ？ 

### a. 外核架构

当谈及操作系统时，人们可能会问的第一个问题是为什么需要它？

我们可以将系统调用实现为一个库，应用程序可以与之链接。

在此方案中，每个应用程序甚至可以根据自己的需求定制自己的库。应用程序可以直接与硬件资源交互，并以应用程序的最佳方式使用这些资源（例如，实现高性能或可预测的性能）。一些嵌入式设备或实时系统的操作系统就是这样组织的。

这种将系统调用实现为库，允许应用程序直接与硬件资源交互并根据需求定制库的操作系统组织方式，被称为 **外核 (Exokernel)**。

在外核架构中，内核的任务不再是提供高层抽象（如文件系统或进程通信），而是专注于**安全地保护资源**。内核仅负责验证访问权限，而将具体的资源管理逻辑（如何使用磁盘、如何分配内存）以库的形式交给应用程序处理。这些库通常被称为**库操作系统 (LibOS)**。

这种库函数方法的缺点是：

> 如果有多个应用程序在运行，这些应用程序必须表现良好。

例如，每个应用程序必须定期放弃中央处理器，以便其他应用程序能够运行。如果所有应用程序都相互信任并且没有错误，这种协同操作的分时方案可能是可以的。 然而更典型的情况是， 应用程序互不信任且存在bug，所以人们通常希望提供比合作方案更强的隔离。

因此，**隔离性**是操作系统提供的一个十分重要的功能。

### b. 强隔离

为了实现强隔离， 最好禁止应用程序**直接访问敏感的硬件资源**，而且将资源抽象为**服务**。

例如，Unix应用程序只通过文件系统的`open`、`read`、`write`和`close`系统调用与存储交互，而不是直接读写磁盘。

这为应用程序提供了方便实用的路径名，并允许操作系统（作为接口的实现者）管理磁盘。即使隔离不是一个问题，有意交互（或者只是希望互不干扰）的程序可能会发现文件系统比直接使用磁盘更方便。

### c. 透明性

Unix在进程之间透明地切换硬件处理器，根据需要保存和恢复寄存器状态，这样应用程序就不必意识到分时共享的存在。

这种**透明性**允许操作系统共享处理器，即使有些应用程序处于无限循环中。

在操作系统设计中，**透明性（Transparency）** 是一个核心设计哲学，它在用户程序与底层硬件资源之间建立了一层“隔离墙”。这种设计让复杂的资源管理对应用程序变得不可见。

#### 1. 硬件状态的“瞬间移动”：上下文切换

Unix 实现透明性的核心手段是 **上下文切换（Context Switch）**。

- **寄存器隔离**：当内核决定切换处理器时，它会将当前进程的所有通用寄存器、程序计数器（PC）和堆栈指针（SP）保存到内存中（在 xv6 中通常保存在 `struct proc` 的 `context` 结构或内核栈中）。
    
- **无感恢复**：当该进程再次获得 CPU 时，内核会将这些值原封不动地写回硬件寄存器。从程序的角度看，时间仿佛“停止”了，然后又从完全相同的状态继续运行。
    
- **寄存器所有权**：这种机制确保了即使多个进程使用相同的物理寄存器名（如 `a0`, `ra`），它们彼此的数据也不会互相干扰。

#### 2. 抢占式多任务：对付无限循环

你提到的“即使应用程序处于无限循环中也能共享处理器”，依赖于 **抢占（Preemption）** 机制。

- **时钟中断（Timer Interrupts）**：硬件时钟会定期（例如每 10 毫秒）向 CPU 发送中断信号。这迫使 CPU 暂停当前运行的代码并进入内核态。
    
- **强制调度**：内核的中断处理程序会调用调度器（Scheduler）。调度器查看当前进程的运行时间，如果太长，就会强制将其切换出去。
    
- **公平性**：如果没有这种透明的抢占，一个写错的 `while(1);` 就会导致整个系统死锁。透明性确保了系统控制权始终握在内核手中。

#### 3. 下表展示了透明性在各维度的体现。

| **维度**    | **透明性的体现**                              | **对你的意义**                                  |
| --------- | --------------------------------------- | ------------------------------------------ |
| **内存透明性** | 每个进程都以为自己拥有从 `0x0` 开始的完整连续内存。           | 你的 `xargs` 读写 `buf` 时，不需要担心会踩到 `find` 的内存。 |
| **时间透明性** | 进程意识不到自己被中断过。                           | 你写代码时不需要手动调用 `yield()` 来让出 CPU。            |
| **资源透明性** | 进程通过系统调用（如 `read`）访问资源，而不必知道磁盘的具体柱面或扇区。 | 你的 `rdline` 函数只需关注文件描述符 `0`，而不管底层是管道还是键盘。  |

### d

图1.2中的系统调用接口是精心设计的，既为程序员提供了便利，又提供了强隔离的可能性。Unix接口不是抽象资源的唯一方法，但它已经被证明是一个非常好的方法