## 10. entry.S 的启动脚本

这段汇编代码是 xv6 内核运行的第一行指令。它的核心任务非常简单：**为每个 CPU 核心（Hart）分配一个独立的启动栈，并跳转到 C 语言环境。**

在 RISC-V 刚上电时，没有任何 C 语言环境（没有栈、没有变量），代码必须从汇编开始。

---

### 1. 指令逐行拆解

代码段

```
_entry:
        # 1. 加载 stack0 的起始地址到栈指针寄存器 sp
        la sp, stack0 
```

- **`la` (Load Address)**：这是一个伪指令，将 `start.c` 中定义的全局数组 `stack0` 的首地址放入 `sp` 寄存器。
- **`stack0`**：内核预留的一块内存，专门用作启动初期的临时栈。

代码段

```
        # 2. 准备每个栈的大小 (4096 字节)
        li a0, 1024*4 
```

- **`li` (Load Immediate)**：将立即数 `4096`（即 4KB）存入寄存器 `a0`。

代码段

```
        # 3. 获取当前 CPU 的硬件 ID (Hart ID)
        csrr a1, mhartid 
```

- **`csrr` (Read CSR)**：读取控制状态寄存器。`mhartid` 存储了当前正在运行的 CPU 核心编号（例如 0, 1, 2...）。
- xv6 默认支持多核（SMP）。每个核必须有自己的栈，否则它们会互相踩踏内存。

代码段

```
        # 4. 计算偏移量并设置 sp 指针
        addi a1, a1, 1      # a1 = hartid + 1
        mul a0, a0, a1      # a0 = 4096 * (hartid + 1)
        add sp, sp, a0      # sp = stack0 + (4096 * (hartid + 1))
```

- **逻辑**：由于栈在 RISC-V 中是**向下生长**的（向低地址生长），所以 `sp` 必须指向该核所属栈空间的**最高地址**。
    
- **示例**：
    
    - Hart 0 的 `sp` = `stack0` + 4096
        
    - Hart 1 的 `sp` = `stack0` + 8192
        

---

### 2. 跳转到 C 语言

代码段

```
        # 5. 调用 start.c 中的 start() 函数
        call start
```

- 有了栈，C 语言的函数调用（保存返回地址、局部变量等）就能正常工作了。
    
- `call start` 标志着内核从汇编时代正式进入 C 语言时代。
    

代码段

```
spin:
        j spin
```

- 如果 `start()` 函数因为某种原因返回了（正常情况下它不应该返回），CPU 会进入这个死循环（spin），防止跑飞到非法指令区。
    

---

### 3. 为什么需要这段代码？（透明性的起点）

正如你之前提到的**透明性**，在 `start()` 函数运行之后，内核会进一步配置页表和中断。

- **硬件屏蔽**：这段汇编直接操作物理寄存器（`sp`, `a0`, `a1`）和 CSR（`mhartid`）。
    
- **环境初始化**：它建立了最基础的“运行时环境”。只有这里分配好了 `sp`，后续在 C 语言里定义的局部变量才能通过偏移量 `sp + offset` 被正确访问。

## 11. start 启动函数

函数`start`执行一些仅在机器模式下允许的配置，然后切换到管理模式。RISC-V提供指令`mret`以进入管理模式，该指令最常用于将管理模式切换到机器模式的调用中返回。而`start`并非从这样的调用返回，而是执行以下操作：它在寄存器`mstatus`中将先前的运行模式改为管理模式，它通过将`main`函数的地址写入寄存器`mepc`将返回地址设为`main`，它通过向页表寄存器`satp`写入0来在管理模式下禁用虚拟地址转换，并将所有的中断和异常委托给管理模式。

在进入管理模式之前，`start`还要执行另一项任务：对时钟芯片进行编程以产生计时器中断。清理完这些“家务”后，`start`通过调用`mret`“返回”到管理模式。这将导致程序计数器（PC）的值更改为`main`(**_kernel/main.c_**:11)函数地址。

在 `entry.S` 完成了最基础的栈设置后，CPU 仍处于最高权限的 **机器模式 (Machine Mode)**。`start()` 函数的核心任务是：**完成硬件底层的初步配置，并从机器模式“降级”切换到内核通常运行的 监管者模式 (Supervisor Mode)，最终跳转到 `main()` 函数。**

以下是代码的逐段详细解析：

---

### 1. 设置特权级转换 (Privilege Mode Transition)


```c
  unsigned long x = r_mstatus();
  x &= ~MSTATUS_MPP_MASK;
  x |= MSTATUS_MPP_S;
  w_mstatus(x);
```

- **逻辑**：RISC-V 使用 `mstatus` 寄存器的 `MPP` 位来记录“执行 `mret` 指令后应该进入哪个模式”。
    
- **操作**：代码将 `MPP` 位设置为 `S` 模式（Supervisor）。这样当函数末尾执行 `mret` 时，硬件会自动将特权级切换到 S 模式。
    

---

### 2. 设置跳转目标 (Setting the Entry Point)

```c
  w_mepc((uint64)main);
```

- **逻辑**：`mepc` (Machine Exception Program Counter) 寄存器存储了执行 `mret` 后 CPU 应该跳转到的地址。
    
- **操作**：将 `main` 函数的地址写入 `mepc`。这意味着切换到 S 模式后，CPU 将从内核的 `main()` 函数开始执行。
    

---

### 3. 禁用分页与中断委托 (Disabling Paging & Delegation)


```c
  w_satp(0);
```

- **操作**：将 `satp` 寄存器置 0 意味着在启动初期**禁用虚拟内存分页**，此时 CPU 直接访问物理地址。


```c
  w_medeleg(0xffff);
  w_mideleg(0xffff);
```

- **逻辑**：默认情况下，所有异常和中断都在 M 模式处理。
    
- **操作**：通过“委托”寄存器，将几乎所有的异常（medeleg）和中断（mideleg）交给 S 模式处理，这样内核才能通过我们之后要写的系统调用逻辑来接管异常。
    

---

### 4. 开启内核中断支持


```c
  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);
```

- **操作**：开启 S 模式下的外部中断（SEIE）、时钟中断（STIE）和软件中断（SSIE）。
    


```c
  timerinit();
```

- **操作**：调用 `timerinit` 配置 CLINT（核心本地中断器）以产生时钟中断。这是实现你之前提到的**透明分时共享**的基础。
    

---

### 5. 存储 CPU ID (The `tp` Register)


```c
  int id = r_mhartid();
  w_tp(id);
```

- **逻辑**：在 S 模式下直接读取 `mhartid` 可能受限。
- **操作**：趁着还在 M 模式，读取当前核心 ID 并存入 `tp` (Thread Pointer) 寄存器。 以后内核代码只需调用 `cpuid()`（读取 `tp`）就能知道当前在哪个核上运行。

---

### 6. 飞跃：执行 `mret`


```c
  asm volatile("mret");
```

- **核心动作**：这是一条特殊的汇编指令。它会同时完成两件事：
    
    1. 根据此前设置的 `mstatus`，将特权级从 **Machine** 切换为 **Supervisor**。
        
    2. 跳转到 `mepc` 指向的地址，即执行 `main()`。
        

---

### 💡 为什么不直接在 M 模式下跑整个内核？

这是为了**安全性（Isolation）**。 M 模式权限太高，可以直接改写硬件任何角落。 将内核运行在 S 模式，而将用户程序运行在 U 模式（User），可以利用页表和硬件限制实现多层保护。

# 11. main 入口函数

```c
void

main()

{

  if(cpuid() == 0){

    consoleinit();

    printfinit();

    printf("\n");

    printf("xv6 kernel is booting\n");

    printf("\n");

    kinit();         // physical page allocator

    kvminit();       // create kernel page table

    kvminithart();   // turn on paging

    procinit();      // process table

    trapinit();      // trap vectors

    trapinithart();  // install kernel trap vector

    plicinit();      // set up interrupt controller

    plicinithart();  // ask PLIC for device interrupts

    binit();         // buffer cache

    iinit();         // inode cache

    fileinit();      // file table

    virtio_disk_init(); // emulated hard disk

    userinit();      // first user process

    __sync_synchronize();

    started = 1;

  } else {

    while(started == 0)

      ;

    __sync_synchronize();

    printf("hart %d starting\n", cpuid());

    kvminithart();    // turn on paging

    trapinithart();   // install kernel trap vector

    plicinithart();   // ask PLIC for device interrupts

  }

  

  scheduler();        

}
```

xv6支持SMP，这是它与其他教学用操作系统不同的地方。通过以上代码我们可以看到，当我们以多核方式运行xv6时，从核（hart 0外的其他hart）会先自旋等待主核完成必要的初始化，再对从核进行初始化，最后调用调度器开始跑第一个用户程序。

必要说明：

---

### 1. `__sync_synchronize()`：内存屏障 (Memory Barrier)

这并不是一个普通的函数，而是一个由编译器（GCC/Clang）提供的**内置原语（Built-in）**。它告诉 CPU 和编译器：**在这里筑起一道墙。**

- **防止指令重排**：为了提高性能，现代 CPU 和编译器经常会打乱指令的执行顺序。例如，主核在初始化时：
    ```c
    kinit();    // A
    started = 1; // B
    ```
    
    如果没有屏障，CPU 可能认为 A 和 B 互不依赖，从而先执行 B。此时，从核看到 `started == 1` 冲了进去，但 `kinit` 还没写完，系统直接崩溃。
    
- **确保内存可见性**：该指令生成 RISC-V 的 `fence` 汇编指令。它强制要求当前核心将所有挂起的“写操作”刷入内存，并确保其他核心能读到最新的值。

附带编写xv6常用的内置函数：

### 🛠️ 编写操作系统必备的 GCC Built-in 总结

在 xv6 或 Linux 内核开发中，以下内置函数是出现频率最高、最不可或缺的：

#### 1. 并发与同步 (Atomic Operations)

在多核 (SMP) 环境下，这些函数确保内存操作的原子性。

- **`__sync_synchronize()`**: 产生一个全内存屏障（Full Memory Barrier），确保指令不被乱序执行。
    
- **`__sync_lock_test_and_set(&lock, value)`**: 原子性地将 `value` 写入 `lock` 并返回旧值。这是实现**自旋锁 (Spinlock)** 的核心。
    
- **`__sync_lock_release(&lock)`**: 原子性地释放锁并清零。
    

#### 2. 内存与指针操作 (Memory Utilities)

内核经常需要手动管理内存布局或初始化结构体。

- **`__builtin_memset(dest, c, n)`**: 虽然内核通常会自己实现 `memset`，但在某些编译器优化场景下，GCC 会自动调用这个内置版本以提高速度。
    
- **`__builtin_memcpy(dest, src, n)`**: 同上，用于高效的内存拷贝。
    
- **`__builtin_return_address(level)`**: 返回当前函数（或其调用者）的返回地址。常用于**内核堆栈回溯 (Stack Backtrace)** 和调试。
    

#### 3. 性能优化与分支预测 (Optimization Hints)

内核代码对执行路径的效率要求极高。

- **`__builtin_expect(exp, c)`**: 告诉编译器表达式 `exp` 的值大概率是 `c`。
    
    - 在内核中常用宏包装：`#define likely(x) __builtin_expect(!!(x), 1)`。
        
    - **作用**：帮助编译器优化流水线和分支预测，减少 CPU 指令跳转开销。
        
- **`__builtin_unreachable()`**: 告诉编译器代码永远不会到达此处。用于优化那些本该死循环或必定异常退出的路径。
    

#### 4. 类型与对齐 (Type & Alignment)

- **`__builtin_types_compatible_p(t1, t2)`**: 判断两个类型是否兼容。在编写通用的内核宏时非常有用。
    
- **`__builtin_offsetof(type, member)`**: 获取结构体成员的偏移量。xv6 和 Linux 内核中的 `container_of` 宏底层往往依赖它。


## 12. userinit 第一个用户程序

```c
// Set up first user process.

void

userinit(void)

{

  struct proc *p;

  p = allocproc();

  initproc = p;

  // allocate one user page and copy init's instructions

  // and data into it.

  uvminit(p->pagetable, initcode, sizeof(initcode));

  p->sz = PGSIZE;

  // prepare for the very first "return" from kernel to user.

  p->trapframe->epc = 0;      // user program counter

  p->trapframe->sp = PGSIZE;  // user stack pointer

  safestrcpy(p->name, "initcode", sizeof(p->name));

  p->cwd = namei("/");

  p->state = RUNNABLE;

  release(&p->lock);

}
```

在`main`(**_kernel/main.c_**:11)初始化几个设备和子系统后，便通过调用`userinit` (**_kernel/proc.c_**:212)创建第一个进程，第一个进程执行一个用RISC-V程序集写的小型程序：initcode.S (user/initcode.S:1)，它通过调用`exec`系统调用重新进入内核。


### 1. 代码逐行详解


```c
void userinit(void) {
  struct proc *p;

  // 1. 分配进程结构体
  p = allocproc(); 
  initproc = p;
```

- **`allocproc()`**：在全局进程表 `proc[NPROC]` 中找一个 `UNUSED` 状态的槽位，初始化其内核栈、进程 ID (PID) 等基础数据。
- **`initproc`**：将这个进程记录在全局变量 `initproc` 中，它是以后所有孤儿进程的“收容所”。
    


```c
  // 2. 初始化虚拟内存与注入 initcode
  uvminit(p->pagetable, initcode, sizeof(initcode));
  p->sz = PGSIZE;
```

- **`uvminit()`**：这是核心步骤。它为进程分配一页（4096 字节）物理内存，并将硬编码在内核里的 `initcode` 机器码拷贝进去。
- **`p->sz`**：设置进程的内存大小为一页。此时，进程的虚拟地址 `0` 处就是 `initcode` 指令的起始位置。
    


```c
  // 3. 伪造“中断返回”现场
  p->trapframe->epc = 0;      // 用户程序计数器
  p->trapframe->sp = PGSIZE;  // 用户栈指针
```

- **`epc = 0`**：告诉 CPU，当从内核态切换到用户态时，从虚拟地址 `0` 开始执行（即 `initcode`）。
- **`sp = PGSIZE`**：将用户栈指针指向这一页内存的顶部（栈向下生长）。
    

```c
  // 4. 设置基本信息与状态
  safestrcpy(p->name, "initcode", sizeof(p->name));
  p->cwd = namei("/");         // 设置根目录为当前工作目录
  p->state = RUNNABLE;         // 标记为就绪状态
  release(&p->lock);           // 释放进程锁
}
```

- **`RUNNABLE`**：一旦状态变为“就绪”，主核或其他核的 `scheduler()`（调度器）就会在下一轮循环中选中它并运行。

### 2. `userinit` 建立的进程内存布局

第一个进程的内存结构非常简单，只有一个物理页：

|**虚拟地址**|**内容**|**说明**|
|---|---|---|
|**0x0000**|`initcode` 指令|包含 `exec("/init")` 的机器码|
|**...**|空闲空间|用于 `initcode` 运行时的临时数据|
|**0x1000**|栈顶 (Initial SP)|指向 `PGSIZE` (4096)|

### 3. 为什么这个函数很重要？

`userinit` 完成了从**内核环境**向**用户环境**的跨越。它手动配置了三件大事：

1. **物理资源**：通过 `kalloc` 分配了第一页用户内存。
2. **映射关系**：通过 `uvminit` 建立了第一张用户页表。
3. **运行环境**：通过 `trapframe` 伪造了一个看起来像是刚被中断的用户态现场。

### 4. initcode 讲解

在 `userinit` 函数中，`initcode` 是 xv6 系统启动的**“第一把火”**。它是一段极小的、直`initcode` 的本质是一个**二进制镜像**（Binary Blob）。它并不是一个普通的 C 函数，而是由 `user/initcode.S` 汇编文件编译出来的**机器指令流**。

在内核编译时，编译器将这段汇编代码转换成 RISC-V 指令，并将其直接嵌入到内核的二进制数据段中。`userinit` 的任务就是创建一个空进程，然后把这段“死数据”像灌装饮料一样灌进这个进程的虚拟内存空间。接用机器码硬编码在内核里的程序。

由于这是系统第一个进程，此时还没有 `exec` 对应的文件系统支持，所以它必须“白手起家”。它的核心任务只有一件事：**通过系统调用加载真正的 `/init` 程序**。

它的逻辑伪代码如下：

1. **准备参数**：将字符串 `"/init"` 的地址放入寄存器。
2. **触发系统调用**：执行 `exec("/init", argv)` 指令。
3. **死循环**：如果 `exec` 失败，就进入死循环。

这就是操作系统“鸡生蛋，蛋生鸡”问题的解法：

- 用户态程序需要 `exec` 系统调用才能从磁盘加载。
- 但 `exec` 必须在某个已经存在的进程中运行。
- `userinit` 配合 `initcode` 手动创造了这个“始祖进程”。一旦 `initcode` 成功执行了 `exec("/init")`，它就会被真正的 `/init` 程序覆盖，从而开启我们熟悉的 Shell 环境。

## 13. userinit.S 用户态起始程序

```
# Initial process that execs /init.

# This code runs in user space.

  

#include "syscall.h"

  

# exec(init, argv)

.globl start

start:

        la a0, init

        la a1, argv

        li a7, SYS_exec

        ecall

  

# for(;;) exit();

exit:

        li a7, SYS_exit

        ecall

        jal exit

  

# char init[] = "/init\0";

init:

  .string "/init\0"

  

# char *argv[] = { init, 0 };

.p2align 2

argv:

  .long init

  .long 0
```

这段汇编代码 `user/initcode.S`是 xv6 系统中**第一个在用户态（User Mode）运行的程序**。它的唯一使命是“点火”：通过调用系统调用来加载并运行真正的初始化程序 `/init`。

以下是这段代码的详细拆解：

---

### 1. 准备 `exec` 系统调用的参数

在 RISC-V 的调用约定中，函数或系统调用的参数通常通过 `a0`, `a1` 等寄存器传递。

代码段

```
# exec(init, argv)
start:
        la a0, init   # 将字符串 "/init\0" 的地址加载到 a0
        la a1, argv   # 将参数数组 argv 的地址加载到 a1
```

- **`la a0, init`**：`init` 标签指向的是字符串 `"/init\0"`。这是 `exec` 系统调用的第一个参数，即要执行的文件路径。
- **`la a1, argv`**：`argv` 标签指向一个指针数组。按照 `exec` 的要求，第二个参数必须是一个以 `NULL` 结尾的数组，其中 `argv[0]` 通常是程序名。
    

---

### 2. 触发系统调用 (`ecall`)

这是从用户态切换到内核态的关键时刻。

代码段

```
        li a7, SYS_exec  # 将系统调用号（SYS_exec）放入 a7
        ecall            # 触发环境调用（Environment Call）
```

- **`li a7, SYS_exec`**：内核通过 `a7` 寄存器来识别用户想要执行哪一个系统调用。
    
- **`ecall`**：这是一条硬件指令。执行它会引发一个异常（Trap），导致 CPU 暂停当前用户程序的运行，提升特权级到 **Supervisor Mode**，并跳转到内核预设的异常处理入口（`trampoline`）。

---

### 3. 错误处理与退出

正常情况下，`exec` 成功后会覆盖当前进程的内存，永远不会返回到这里。如果代码运行到了 `exit` 标签，说明 `exec` 失败了。

代码段

```
exit:
        li a7, SYS_exit  # 如果 exec 失败，准备调用 exit 系统调用
        ecall            # 再次触发 ecall 进入内核注销进程
        jal exit         # 如果 exit 也失败了，就在这里死循环（Jump and Link）
```

---

### 4. 数据段定义

这些数据会被 `userinit` 函数通过 `uvminit` 拷贝到物理内存页中。

代码段

```
init:
  .string "/init\0"      # 定义文件路径字符串

.p2align 2               # 确保 4 字节对齐（指针需要对齐访问）
argv:
  .long init             # argv[0] 指向上面的字符串地址
  .long 0                # argv[1] 为 NULL，标记数组结束
```

## 14. init.c 用户态初始化程序

```c
// init: The initial user-level program

  

#include "kernel/types.h"

#include "kernel/stat.h"

#include "kernel/spinlock.h"

#include "kernel/sleeplock.h"

#include "kernel/fs.h"

#include "kernel/file.h"

#include "user/user.h"

#include "kernel/fcntl.h"

  

char *argv[] = { "sh", 0 };

  

int

main(void)

{

  int pid, wpid;

  

  if(open("console", O_RDWR) < 0){

    mknod("console", CONSOLE, 0);

    open("console", O_RDWR);

  }

  dup(0);  // stdout

  dup(0);  // stderr

  

  for(;;){

    printf("init: starting sh\n");

    pid = fork();

    if(pid < 0){

      printf("init: fork failed\n");

      exit(1);

    }

    if(pid == 0){

      exec("sh", argv);

      printf("init: exec sh failed\n");

      exit(1);

    }

  

    for(;;){

      // this call to wait() returns if the shell exits,

      // or if a parentless process exits.

      wpid = wait((int *) 0);

      if(wpid == pid){

        // the shell exited; restart it.

        break;

      } else if(wpid < 0){

        printf("init: wait returned an error\n");

        exit(1);

      } else {

        // it was a parentless process; do nothing.

      }

    }

  }

}
```

在内核搭起第一个用户进程后，之后发生的一切都很简单了。init.c拉起了一个shell，使得用户程序可以正常运转。

