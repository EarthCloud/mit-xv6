## 1. RISC-V的地址映射

RISC-V指令（用户和内核指令）使用的是虚拟地址，而机器的RAM或物理内存是由物理地址索引的。RISC-V页表硬件通过将每个虚拟地址映射到物理地址来为这两种地址建立联系。

XV6基于Sv39 RISC-V运行，这意味着它只使用64位虚拟地址的低39位；而高25位不使用。

在这种Sv39配置中，RISC-V页表在逻辑上是一个由 $2^{27}$ 个页表条目（Page Table Entries/PTE）组成的数组，每个PTE包含一个44位的物理页码（Physical Page Number/PPN）和一些标志。

**分页硬件**通过使用虚拟地址39位中的前27位索引页表，以找到该虚拟地址对应的一个PTE，然后生成一个56位的物理地址，其前44位来自PTE中的PPN，其后12位来自原始虚拟地址。

页表使操作系统能够以 4096 ( $2^{12}$ ) 字节的对齐块的粒度控制虚拟地址到物理地址的转换，这样的块称为页（page）。

![Pasted image 20260123003030.png](./assets/vapa.png)

在Sv39 RISC-V中，虚拟地址的前25位**不用于转换**；将来RISC-V可能会使用那些位来定义更多级别的转换。RISC-V 的设计者根据**技术预测**选择了这些数字。

 $2^{39}$ 字节是 512 GB，这应该足够让应用程序运行在 RISC-V 计算机上。 $2^{56}$ 的物理内存空间在不久的将来足以容纳可能的 I/O 设备和 DRAM 芯片。 如果需要更多，RISC-V 设计人员定义了具有 48 位虚拟地址的 Sv48。

这里我们就需要详细讲一讲Sv39 RISC-V到底是什么：

简单来说：**Sv39 是 RISC-V 架构手册（ISA）中定义的一种分页方案规格，它的寻址过程是由 CPU 硬件直接完成的，但页表的内容必须由内核来维护。**

Sv39 是一套“硬件标准”，它强制规定了硬件如何看待地址：

- **地址宽度**：它规定虚拟地址为 64 位，但只有低 39 位有效。
    
- **页表级数**：它规定必须使用三级页表结构。
    
- **PTE 格式**：它严格规定了一个 64 位的页表条目（PTE）中，哪几位是物理页码（PPN），哪几位是标志位（如 V 代表有效，R/W/X 代表权限）。
    
- **控制寄存器**：它规定 CPU 必须有一个 `satp` 寄存器，用来存放根页表的物理地址。

## 2. 实际转换与三级映射

![translation detail.png](./assets/translation_detail.png)

如果转换地址所需的三个PTE中的任何一个不存在，页式硬件就会引发页面故障异常（page-fault exception），并让内核来处理该异常（参见第4章）。

与图 3.1 的单级设计相比，图 3.2 的三级结构使用了一种更节省内存的方式来记录 PTE。在大范围的虚拟地址没有被映射的常见情况下，三级结构可以忽略整个页面目录。

我们可以做一个简单的计算，如果直接映射，那么单就一个页表就占用 $2^{27} \times 8 = 2^{30} = 1GiB$ ，这个内存开销不可接受。而我们如图所示的三级页表模式则可以忽略整个页面目录。举个例子，如果一个应用程序只使用了一个页面，那么顶级页面目录将只使用条目0，条目 1 到 511 都将被忽略，因此内核不必为这511个条目所对应的中间页面目录分配页面，也就更不必为这 511 个中间页目录分配底层页目录的页。 所以，在这个例子中，三级设计仅使用了三个页面，共占用 $3\times4096$个字节。

因为 CPU 在执行转换时会在硬件中遍历三级结构，所以缺点是 CPU 必须从内存中加载三个 PTE 以将虚拟地址转换为物理地址。为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将页表条目缓存在 Translation Look-aside Buffer (TLB) 中。

每个PTE包含标志位，这些标志位告诉分页硬件允许如何使用关联的虚拟地址。`PTE_V`指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。`PTE_R`控制是否允许指令读取到页面。`PTE_W`控制是否允许指令写入到页面。`PTE_X`控制CPU是否可以将页面内容解释为指令并执行它们。`PTE_U`控制用户模式下的指令是否被允许访问页面；如果没有设置`PTE_U`，PTE只能在管理模式下使用。图3.2显示了它是如何工作的。标志和所有其他与页面硬件相关的结构在（**_kernel/riscv.h_**）中定义。

```c
#define PTE_V (1L << 0) // valid

#define PTE_R (1L << 1)

#define PTE_W (1L << 2)

#define PTE_X (1L << 3)

#define PTE_U (1L << 4) // 1 -> user can access

// shift a physical address to the right place for a PTE.

#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)

#define PTE2PA(pte) (((pte) >> 10) << 12)

#define PTE_FLAGS(pte) ((pte) & 0x3FF)


// extract the three 9-bit page table indices from a virtual address.

#define PXMASK          0x1FF // 9 bits

#define PXSHIFT(level)  (PGSHIFT+(9*(level)))

#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)

// one beyond the highest possible virtual address.

// MAXVA is actually one bit less than the max allowed by

// Sv39, to avoid having to sign-extend virtual addresses

// that have the high bit set.

#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
```

文件中的宏标记了这一位的位置。

为了告诉硬件使用页表，内核必须将根页表页的物理地址写入到`satp`寄存器中（`satp`的作用是存放根页表页在物理内存中的地址）。每个CPU都有自己的`satp`，一个CPU将使用自己的`satp`指向的页表转换后续指令生成的所有地址。每个CPU都有自己的`satp`，因此不同的CPU就可以运行不同的进程，每个进程都有**自己的页表描述的私有地址空间**。

## 3. 内核的映射方式

通常，内核将所有物理内存映射到其页表中，以便它可以使用加载/存储指令读取和写入物理内存中的任何位置。

在 xv6 中，内核在启动时会建立一个特殊的页表映射。它把物理地址 $X$ 直接映射到虚拟地址 $X$（或者一个固定的偏移地址 $X + \text{Offset}$）。

- **物理背景**：内存条上的每一个字节都有一个物理地址。
    
- **内核特权**：通过这种“等值映射”，内核只要知道一个物理地址，就可以直接通过对应的虚拟地址去访问它。
    
- **结果**：如果内核想修改物理内存中 `0x80005000` 处的一个字节，它只需要在 C 语言里操作指针 `*(char*)0x80005000 = 0x1`，硬件 MMU 就会通过内核页表将该操作导向正确的物理位置。

由于页目录位于物理内存中，内核可以通过使用标准存储指令写入 PTE 的虚拟地址来对页目录中的 PTE 内容进行编程。

这是一个“套娃”式的逻辑，也是理解分页机制最绕的地方：**页表本身也存在内存里。**

- **页表不是硬盘，是 RAM**：Sv39 的三级页表其实就是一堆 4096 字节大小的内存块。
    
- **如何修改映射？**：
    
    1. 如果你（内核）想把用户进程的虚拟地址 `0x4000` 映射到物理地址 `0x9000`。
        
    2. 你首先要找到存储该进程页表的那个物理页（假设页表在物理地址 `0x80001000`）。
        
    3. 利用第一点提到的“全能视角”，内核直接访问虚拟地址 `0x80001000`。
        
    4. 使用标准的 C 语言赋值语句（存储指令），往这个地址里写入一个新的 64 位数值（PTE）。
        
- **生效过程**：一旦内核完成了这次写入，下次 CPU 硬件 MMU 去查表时，读到的就是你刚刚写进去的新映射关系了。

这两句话勾勒出了内核管理内存的闭环：

1. **硬件层面**：CPU 总是通过页表来访问内存。
    
2. **软件层面**：内核通过修改页表来控制硬件。
    
3. **矛盾点**：修改页表这个动作本身也需要访问内存（即访问页表所在的内存）。
    
4. **解决方案**：内核页表包含了一张“地图”，这张地图覆盖了整个物理内存空间，使得内核能够“看到”并“修改”任何一个页表条目。