## 9. 内核的内存分配职责

内核必须在**运行时**为页表、用户内存、内核栈和管道缓冲区分配和释放物理内存。

xv6使用内核末尾到`PHYSTOP`之间的物理内存进行运行时分配。

它一次分配和释放整个4096字节的页面。它使用链表的数据结构将空闲页面记录下来（freelist）。分配时需要从链表中删除页面；释放时需要将释放的页面添加到链表中。

## 10. 内存分配器

分配器(allocator)位于kalloc.c(**_kernel/kalloc.c_**:1)中。

分配器的数据结构是**可供分配的物理内存页的空闲列表**，它以链表的形式进行组织，每个空闲页的列表元素是一个`struct run`(**_kernel/kalloc.c_**:17)，它的原型如下：

```c
struct run {

  struct run *next;

};
```

它只存放了一个指向下一个空闲页的指针，因为这个页是空页，并没有存储任何东西，只要寻址到它的首地址即可。

空闲列表受到自旋锁（spin lock）的保护(**_kernel/kalloc.c_**:21-24)，现在，忽略锁以及对`acquire`和`release`的调用；第6章将详细查看有关锁的细节。列表和锁被封装在一个结构体中，以明确锁在结构体中保护的字段。

```c
struct {

  struct spinlock lock;

  struct run *freelist;

} kmem;
```

freelist指向了空闲链表的首节点，以此来进行一系列链表操作。

`main`函数调用`kinit`(**_kernel/kalloc.c_**:27)来初始化分配器。`kinit`初始化空闲列表以保存从内核结束到`PHYSTOP`之间的每一页。xv6应该通过解析硬件提供的配置信息来确定有多少物理内存可用。
然而，xv6假设机器有128兆字节的RAM，因此，PHYSTOP常量被定义为`0x80000000L + 128*1024*1024`，`kinit`调用`freerange`将内存添加到空闲列表中，在`freerange`中每页都会调用`kfree`。PTE只能引用在4096字节边界上对齐的物理地址（是4096的倍数），所以`freerange`使用`PGROUNDUP`来确保它只释放对齐的物理地址。分配器开始时没有内存；这些对`kfree`的调用给了它一些可以进行管理的空间。

```c
void

kinit()

{

  initlock(&kmem.lock, "kmem");

  freerange(end, (void*)PHYSTOP);

}

  

void

freerange(void *pa_start, void *pa_end)

{

  char *p;
  // 为了维护对齐，其向上取4096整
  p = (char*)PGROUNDUP((uint64)pa_start);

  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)

    kfree(p);

}
```

`kfree`检测了每一页是否对齐，并且在释放时填写垃圾信息以阻止悬引用（C中的野指针），随后在空闲页首中插入该链表。

这里，填入垃圾信息1（对于memset来说，他是逐字节的0x01），如果出现悬垂引用，它会立刻崩溃，避免静默失败。例如，在 C 语言中，很多函数会写成 `if (ptr) { ... }`。如果内存被填 `0` 成了 `NULL`，悬引用指针在访问时可能会因为命中这些检查而**静默地跳过**执行；如果一个计数器或状态位在释放后被读取，读取到 `0` 往往被程序认为是一个“正常”的初始值。同时，它也能区分“未初始化”和“已释放”，如果你在 GDB 调试中看到一个变量的值是 `0x01010101`，一眼就能断定：**“我在使用一块已经还给 freelist 的内存”**。如果它是 `0x00`，可能分不清它是还没赋值，还是已经被释放了。

最重要的是，在 RISC-V 中，一个页表项（PTE）如果全为 `0`，代表该映射**无效（Invalid）**。如果 `kfree` 填 `0`：在 `walk` 或者 `copyin` 时遇到这个 PTE，逻辑可能会认为“这个页面还没映射”，然后走缺失流程。，如果填1，由于valid位是低第一位，它仍然为1，在访问时很快就会崩溃。

分配器有时将地址视为整数，以便对其执行算术运算（例如，在`freerange`中遍历所有页面），有时将地址用作读写内存的指针（例如，操纵存储在每个页面中的`run`结构）；这种地址的双重用途是分配器代码充满C类型转换的主要原因。另一个原因是释放和分配从本质上改变了内存的类型。由此也可以看出，C是弱类型语言（允许将指针强制转换为任意类型）。

`kalloc`删除并返回空闲列表中的第一个元素。

```c
// Allocate one 4096-byte page of physical memory.

// Returns a pointer that the kernel can use.

// Returns 0 if the memory cannot be allocated.

void *

kalloc(void)

{

  struct run *r;

  

  acquire(&kmem.lock);

  r = kmem.freelist;

  if(r)

    kmem.freelist = r->next;

  release(&kmem.lock);

  

  if(r)

    memset((char*)r, 5, PGSIZE); // fill with junk

  return (void*)r;

}
```