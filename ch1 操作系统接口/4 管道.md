管道是作为一对文件描述符公开给进程的小型内核缓冲区，一个用于读取，一个用于写入。将数据写入管道的一端使得这些数据可以从管道的另一端读取。管道为进程提供了一种通信方式。
## 8. 管道使用示例

下面的示例代码使用连接到管道读端的标准输入来运行程序`wc`。

```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);  // 使用pipe创建一个管道，具有读端和写端
	if (fork() == 0) { // 如果是子进程（要执行ws）
    close(0);  // 先关闭默认的读取的fd
    dup(p[0]);  // 复制一个管道的fd，由于0被关闭，这个读端分配的fd为0
    close(p[0]); // 关闭不用读端，只保留0
    close(p[1]); // 写端本来就不需要，关闭
    exec("/bin/wc", argv); // 执行exec进行程序替换
} else {  // 如果是父进程
    close(p[0]);  // 关闭不需要的读端，只写入
    write(p[1], "hello world\n", 12); // 向写端进行写入
    close(p[1]); //关闭写端
}

```

程序调用`pipe`，创建一个新的管道，并在数组p中记录读写文件描述符。在`fork`之后，父子进程都有指向管道的文件描述符。子进程调用`close`和`dup`使文件描述符0指向管道的读取端（前面说过优先分配最小的未使用的描述符），然后关闭p中所存的文件描述符，并调用`exec`运行`wc`。当`wc`从它的标准输入读取时，就是从管道读取。父进程关闭管道的读取端，写入管道，然后关闭写入端。

如果没有可用的数据，则管道上的`read`操作将会进入等待，直到有新数据写入或所有指向写入端的文件描述符都被关闭，在后一种情况下，`read`将返回0，就像到达数据文件的末尾一样。

事实上，`read`在新数据不可能到达前会一直阻塞，这是子进程在执行上面的`wc`之前关闭管道的写入端非常重要的一个原因：如果wc的文件描述符之一指向管道的写入端，wc将永远看不到文件的结束。

**核心注意**：如果不关闭写端，读端永远不知道数据什么时候发完，会造成死锁。

#### 为什么要关闭未使用的端口？（极重要！）

这是新手写管道程序最容易卡死（Hang）的原因。

**原理：** `read(p[0], ...)` 会一直阻塞等待数据，直到发生以下两种情况之一才返回：

1. 读到了数据。
2. **所有的写端（`p[1]`）都被关闭了**。此时 `read` 会返回 0，表示“文件结束”（EOF）。

**陷阱：** 如果你在子进程里读，但忘记了关闭子进程手里的那个 `p[1]`。 哪怕父进程已经关闭了它的 `p[1]` 并且退出了，内核会认为：“咦？子进程自己手里还捏着一个写端 `p[1]` 呢，说不定它等会儿想给自己写点东西？” 于是，管道的引用计数不为 0，`read` 永远收不到 EOF，程序就会永远卡在 `read` 哪里不动。

**口诀：** **不用的一定要关掉！写完了一定要关掉！**

### I 标准范式：父写子读

这是一个经典的通信流程：

1. **父进程**调用 `pipe(p)`。（此时父进程手里拿着 `p[0]` 和 `p[1]`）。
2. **父进程**调用 `fork()`。
    - 此时，**父进程**有 `p[0]` 和 `p[1]`。
    - **子进程**也有 `p[0]` 和 `p[1]`。
    - （现在有 4 个口连接着这根管子！）
3. **关闭不需要的端口（关键！）**：
    - 如果父进程只想写，它应该关闭自己的读端 `p[0]`。
    - 如果子进程只想读，它应该关闭自己的写端 `p[1]`。
4. **通信**：父进程往 `p[1]` 写，子进程从 `p[0]` 读。

## 9. 管道的用途

你一定用过这个命令：


```bash
ls | grep txt
```

Shell（`sh.c`）在执行这句话时，做了以下魔法：

1. 创建管道。
2. Fork `ls` 进程：把 `ls` 的**标准输出（fd 1）**“偷梁换柱”，重定向到管道的**写端**。
3. Fork `grep` 进程：把 `grep` 的**标准输入（fd 0）**“偷梁换柱”，重定向到管道的**读端**。

这样，`ls` 以为自己在往屏幕打印，其实打印进了管子；`grep` 以为自己在读键盘，其实是在读管子。两个原本不认识的程序，就这样完美协作了。