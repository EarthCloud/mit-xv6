## 3. 进程和内存

xv6进程由以下部分组成：

- 用户空间内存(指令、数据和堆栈)
- 对内核私有的每个进程状态

### 分时实现（并发）

xv6分时进程（time-shares processes）：它透明地在等待执行的进程集合中**切换**可用的CPU。当一个进程没有执行时，xv6保存它的CPU寄存器，并在下一次运行该进程时恢复它们。因此，这是控制并发的关键进程。

提供Gemini对xv6分时实现的解释：

在 xv6 中，分时（Time-sharing）是通过**时钟中断**（Timer Interrupt）和**上下文切换**（Context Switching）来实现的。它让每个 CPU 核心在短时间内轮流执行不同的进程，从而营造出“多个进程同时运行”的假象。

流程：

1. 时钟中断：硬件时钟芯片会周期性地（例如每 10ms）向 CPU 发送一个中断信号。
2. 让出 CPU（`yield`）：当内核识别出这是一个时钟中断（`devintr() == 2`）时，它知道当前进程的时间片（Time Slice）用完了。便会让出CPU，将该进程状态由RUNNING设置为RUNNABLE
3. 调度器循环（`scheduler`）：每个 CPU 都有一个专门的调度器线程，它扫描进程表（Process Table `proc[]`），寻找状态为 **RUNNABLE** 的进程。一旦找到，它将该进程状态改为 **RUNNING**。
4. 上下文切换（`swtch`）：将当前 CPU 的寄存器（ra, sp, s0-s11 等）保存到旧进程（或调度器）的 `context` 结构体中，再从新进程的 `context` 结构体中加载寄存器值到 CPU。当 `swtch` 返回时，CPU 实际上已经处于新进程的代码流中了（通常是回到该进程上次调用 `swtch` 的地方）。

以下是xv6 的源码`kernel/proc.h` 中的 `struct proc`：
```c
struct proc {

  struct spinlock lock;


  enum procstate state;        // Process state


  struct context context;      // swtch() here to run process


};
```

- `state`: 记录进程是 `RUNNING`, `RUNNABLE`, 还是 `SLEEPING`。
- `context`: 只有在进程**不运行**时（被挂起时）才会有意义，用于存储内核线程的寄存器快照。

state有以下枚举类型：

```c
enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
```

context内容如下：

```c
// Saved registers for kernel context switches.

struct context {

  uint64 ra;

  uint64 sp;

  // callee-saved

  uint64 s0;

  uint64 s1;

  uint64 s2;

  uint64 s3;

  uint64 s4;

  uint64 s5;

  uint64 s6;

  uint64 s7;

  uint64 s8;

  uint64 s9;

  uint64 s10;

  uint64 s11;

};
```

### fork: 创建新进程

fork创建了一个新的进程，其内存内容与调用进程（称为父进程）完全相同，称其为子进程。Fork在父子进程中都返回值。在父进程中，fork返回子类的PID；在子进程中，fork返回零。

这是一个使用fork的程序片段：

```c
// fork()在父进程中返回子进程的PID
// 在子进程中返回0
int pid = fork();
if(pid > 0) {
    printf("parent: child=%d\n", pid);
    pid = wait((int *) 0);
    printf("child %d is done\n", pid);
} else if(pid == 0) {
    printf("child: exiting\n");
    exit(0);
} else {
    printf("fork error\n");
}

```

- `exit`系统调用导致调用进程停止执行并释放资源（如内存和打开的文件）。`exit`接受一个整数状态参数，通常0表示成功，1表示失败。
- `wait`系统调用返回当前进程的已退出(或已杀死)子进程的PID，并将子进程的退出状态复制到传递给`wait`的地址；如果调用方的子进程都没有退出，那么wait等待一个子进程退出。如果调用者没有子级，`wait`立即返回-1。

在这里，我有两个问题，Gemini的回复如下：

#### Q1：为什么子进程不会无限递归调用 `fork`？

**简短回答：** 因为 `fork()` 复制出来的子进程，并不是从头开始执行代码的，而是**从 `fork()` 函数返回的那一瞬间**开始执行的。

当父进程调用 `fork()` 时，操作系统会做两件事：
1. **复制内存：** 把父进程的代码段、数据段、堆栈完全复制一份给子进程。
2. **复制执行状态（关键）：** 它会复制父进程的**程序计数器（Program Counter / PC）**。

#### Q2：`wait((int *) 0)` 是什么意思？

**简短回答：**`wait` 函数需要一个**地址**来存放子进程的退出状态，而 `(int *) 0` 等同于 **`NULL`（空指针）**，表示“我不关心退出状态，不要存了”。

在 Linux/UNIX 标准中，`wait` 的原型如下：

```c
pid_t wait(int *status);
```

**参数 `status`**：这是一个指向整数的指针 (`int *`)。操作系统利用这个指针，将子进程死掉的原因（正常退出还是报错？退出码是多少？）**写入**该指针指向的内存地址中。

强转的0相当于把整数 `0` 强行解释为一个 `int` 类型的指针地址（即地址 0x0），在现代C语言中，通常直接写NULL。

尽管最初子进程与父进程有着相同的内存内容，但是二者在运行中拥有不同的内存空间和寄存器：在一个进程中改变变量不会影响到另一个进程。例如当`wait`的返回值存入父进程的变量`pid`中时，并不会影响子进程中的`pid`，子进程中`pid`仍然为0。

### exec：替换调用进程的内存

根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，**就是在调用进程内部执行一个可执行文件**。

该文件必须有特殊的格式，它指定文件的哪部分存放指令，哪部分是数据，以及哪一条指令用于启动等等。xv6使用ELF格式（将会在第三章详细讨论）。

当`exec`执行成功，它不向调用进程返回数据，而是使加载自文件的指令在`ELF header`中声明的程序入口处开始执行。可以理解为直接替换为文件加载的进程。

`exec`有两个参数：可执行文件的文件名和字符串参数数组。

观察如下代码：

```c
char* argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");

```

这个代码片段将调用程序替换为了参数列表为`echo hello`的`/bin/echo`程序运行，多数程序忽略参数数组中的第一个元素，它通常是程序名。注意，0代表字符串组的结尾。

这里有两个关于C语言的问题：

#### Q1：为什么最后要有一个 0 (`argv[2] = 0`)？

该问题在Robert的课堂上也提出过。

**简短回答：** 这是一个**终止符（Sentinel）**，告诉内核或 `exec` 函数：“参数列表到这里结束了”。

**详细解释：** C 语言中的数组（尤其是指针数组）本身并不携带“长度信息”。 当你把 `argv` 数组传给系统调用 `exec(path, argv)` 时，操作系统只拿到了数组的首地址。操作系统会从这个地址开始，一个接一个地读取字符串指针：

- 读第 1 个：`"echo"` -> 有效
- 读第 2 个：`"hello"` -> 有效
- 读第 3 个：**如果是 0 (NULL)** -> **停止读取，参数结束**。

**如果没有这个 0 会发生什么？** 操作系统会继续往后读内存，直到读到垃圾数据或者访问非法内存导致崩溃（Segmentation Fault）。这就像 C 语言字符串必须以 `\0` 结尾一样，字符串数组（参数列表）必须以 `NULL` 指针结尾。

**注意**：这里的 `0` 会被编译器隐式转换为 `(char *)NULL` 空指针。也回应了上个问题。

#### Q2：为什么多数程序忽略第一个元素 (`argv[0]`)？

**简短回答：** 因为按照约定，`argv[0]` 存储的是**程序自己的名字**，而不是用户传递给程序的参数。

**详细解释：**

这是一个约定俗称的标准

当你在 shell 中输入命令 `ls -l` 时，Shell 会这样构建参数数组：

- `argv[0] = "ls"` (程序名)
- `argv[1] = "-l"` (参数)
- `argv[2] = NULL`

对于大多数程序的逻辑（比如 `echo`），它只需要处理用户让它做的事情（打印 "hello"），而不需要处理它自己叫什么名字。因此，程序通常从 `argv[1]` 开始循环处理实际的输入。

### shell：使用上述为用户运行程序

shell的主要结构很简单，参见`main`(**_user/sh.c:145_**)，文中展示了关键的while循环：

主循环使用`getcmd`函数从用户的输入中读取一行，然后调用`fork`创建一个shell进程的副本（else后面的内容）。父进程调用`wait`，子进程执行命令。

```c
while(getcmd(buf, sizeof(buf)) >= 0){

    char *cmd = buf;

    while (*cmd == ' ' || *cmd == '\t')

      cmd++;  // 去除前导空格

    if (*cmd == '\n') // 如果是空命令

      continue;
      

    if(cmd[0] == 'c' && cmd[1] == 'd' && cmd[2] == ' '){

      // Chdir must be called by the parent, not the child.

      cmd[strlen(cmd)-1] = 0;  // chop \n

      if(chdir(cmd+3) < 0)

        fprintf(2, "cannot cd %s\n", cmd+3);

    } else {

      if(fork1() == 0)

        runcmd(parsecmd(cmd));

      wait(0);

    }

  }

```

getcmd的实现十分简单，主要是从用户输入中读取一行：

```c
int

getcmd(char *buf, int nbuf)

{

  write(2, "$ ", 2);

  memset(buf, 0, nbuf);

  gets(buf, nbuf);

  if(buf[0] == 0) // EOF

    return -1;

  return 0;

}
```

0代表正常读入了数据，满足while循环条件后进入循环中执行，上面考虑了cd命令，我们只需要关注else后面的语句即可，fork1(***user/sh.c:187***)是一个调用fork的函数：

```c
int

fork1(void)

{

  int pid;

  pid = fork();

  if(pid == -1)

    panic("fork");

  return pid;

}
```

这个 `panic` 函数是 xv6 Shell (`sh.c`) 用来处理**不可恢复的致命错误**的辅助函数。简单来说，当 Shell 遇到一个它无法处理的情况（比如内存耗尽、逻辑由于代码 bug 而崩溃），它会调用这个函数来**报错并自杀**。

panic函数的原型如下：

```c
void panic(char *s)
{
  // 第一步：向“标准错误”输出报错信息
  fprintf(2, "%s\n", s);
  
  // 第二步：以“错误状态”终止当前进程
  exit(1);
}
```

在xv6中，标准错误的fd被定义为2，因为标准输出1可能会被重定向到文件。

fork1执行到`pid = fork();`时，会复制一个子进程并返回获取到的pid，如果pid是0，就代表该进程为子进程，那么就可以执行runcmd，进入到子进程中，runcmd的实现如下：

```c
void

runcmd(struct cmd *cmd)

{

  int p[2];

  struct backcmd *bcmd;

  struct execcmd *ecmd;

  struct listcmd *lcmd;

  struct pipecmd *pcmd;

  struct redircmd *rcmd;

  

  if(cmd == 0)

    exit(1);

  

  switch(cmd->type){

  default:

    panic("runcmd");

  

  case EXEC:

    ecmd = (struct execcmd*)cmd;

    if(ecmd->argv[0] == 0)

      exit(1);

    exec(ecmd->argv[0], ecmd->argv);

    fprintf(2, "exec %s failed\n", ecmd->argv[0]);

    break;
    
}

  exit(0);
}
```

我在这里只保留了EXEC的宏对应的switch块，只需明白，调用exec执行后，会使用exit退出子进程，回到shell，shell的具体实现会在之后进一步深入。

你或许想知道为什么`exec`和`fork`没有组合成为一个系统调用，稍后我们将会看到shell在其I/O重定向的实现中利用了这种分离。为了避免创建一个重复的进程然后立即替换它(使用`exec`)的浪费，操作内核通过使用虚拟内存技术(如copy-on-write)优化 fork 在这个用例中的实现(见第 4.6 节)。

Xv6 隐式地分配大多数用户空间内存:`fork`分配父内存的子副本所需的内存，`exec`分配足够的内存来保存可执行文件。在运行时需要更多内存的进程(可能是`malloc`)可以调用 `sbrk(n)`将其数据内存增加n个字节; `sbrk`返回新内存的位置。